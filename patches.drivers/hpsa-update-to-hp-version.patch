From: Mike Miller <mike.miller@hp.com>
Date: Fri, 1 Jul 2011 11:32:58 +0200
Subject: hpsa: Update to latest code drop from HP
References: FATE#311201,bnc#703426
Patch-Mainline: Not yet.

This patch updates the hpsa driver to the latest code-drop from HP.

Signed-off-by: Mike Miller <mike.miller@hp.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/scsi/hpsa.c     |  191 ++++++++++++++++++++++++++++++++----------------
 drivers/scsi/hpsa.h     |   29 ++++++-
 drivers/scsi/hpsa_cmd.h |    8 ++
 3 files changed, 165 insertions(+), 63 deletions(-)

diff --git a/drivers/scsi/hpsa.c b/drivers/scsi/hpsa.c
index eec82d6..accffe3 100644
--- a/drivers/scsi/hpsa.c
+++ b/drivers/scsi/hpsa.c
@@ -52,7 +52,7 @@
 #include "hpsa.h"
 
 /* HPSA_DRIVER_VERSION must be 3 byte values (0-255) separated by '.' */
-#define HPSA_DRIVER_VERSION "2.0.2-1"
+#define HPSA_DRIVER_VERSION "110526.863-1"
 #define DRIVER_NAME "HP HPSA Driver (v " HPSA_DRIVER_VERSION ")"
 
 /* How long to wait (in milliseconds) for board to go into simple mode */
@@ -88,7 +88,6 @@ static const struct pci_device_id hpsa_pci_device_id[] = {
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3249},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x324a},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x324b},
-	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSE,     0x103C, 0x3233},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3350},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3351},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3352},
@@ -96,7 +95,9 @@ static const struct pci_device_id hpsa_pci_device_id[] = {
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3354},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3355},
 	{PCI_VENDOR_ID_HP,     PCI_DEVICE_ID_HP_CISSF,     0x103C, 0x3356},
-	{PCI_VENDOR_ID_HP,     PCI_ANY_ID,	PCI_ANY_ID, PCI_ANY_ID,
+	{PCI_VENDOR_ID_HP,     PCI_ANY_ID,      PCI_ANY_ID, PCI_ANY_ID,
+		PCI_CLASS_STORAGE_RAID << 8, 0xffff << 8, 0},
+	{PCI_VENDOR_ID_COMPAQ,     PCI_ANY_ID,  PCI_ANY_ID, PCI_ANY_ID,
 		PCI_CLASS_STORAGE_RAID << 8, 0xffff << 8, 0},
 	{0,}
 };
@@ -531,17 +532,22 @@ static void enqueue_cmd_and_start_io(struct ctlr_info *h,
 	unsigned long flags;
 
 	set_performant_mode(h, c);
-	spin_lock_irqsave(&h->lock, flags);
+	flags = h->access.lock(h);
 	addQ(&h->reqQ, c);
 	h->Qdepth++;
 	start_io(h);
-	spin_unlock_irqrestore(&h->lock, flags);
+	h->access.unlock(h, flags);
 }
 
 static inline void removeQ(struct CommandList *c)
 {
-	if (WARN_ON(list_empty(&c->list)))
+	int empty;
+
+	empty = list_empty(&c->list);
+	if (empty) {
+		WARN_ON(empty);
 		return;
+	}
 	list_del_init(&c->list);
 }
 
@@ -1898,13 +1904,17 @@ static void hpsa_update_scsi_devices(struct ctlr_info *h, int hostno)
 		hpsa_set_bus_target_lun(this_device, bus, target, lun);
 
 		switch (this_device->devtype) {
-		case TYPE_ROM: {
+		case TYPE_ROM:
+
+			if (!h->software_raid) { /* Real Smart Array? */
+
 			/* We don't *really* support actual CD-ROM devices,
-			 * just "One Button Disaster Recovery" tape drive
-			 * which temporarily pretends to be a CD-ROM drive.
-			 * So we check that the device is really an OBDR tape
-			 * device by checking for "$DR-10" in bytes 43-48 of
-			 * the inquiry data.
+			 * on real Smart Arrays, just "One Button Disaster
+			 * Recovery" tape drive which temporarily pretends to
+			 * be a CD-ROM drive.  So we check that the device is
+			 * really an OBDR tape device by checking for "$DR-10"
+			 * in bytes 43-48 of the inquiry data.  We do support
+			 * CD-ROMs on software RAID "Smart Arrays" though.
 			 */
 				char obdr_sig[7];
 #define OBDR_TAPE_SIG "$DR-10"
@@ -1913,7 +1923,7 @@ static void hpsa_update_scsi_devices(struct ctlr_info *h, int hostno)
 				if (strncmp(obdr_sig, OBDR_TAPE_SIG, 6) != 0)
 					/* Not OBDR device, ignore it. */
 					break;
-			}
+			} /* else, it's a software RAID "Smart Array" */
 			ncurrent++;
 			break;
 		case TYPE_DISK:
@@ -2540,7 +2550,7 @@ static int hpsa_passthru_ioctl(struct ctlr_info *h, void __user *argp)
 		buff = kmalloc(iocommand.buf_size, GFP_KERNEL);
 		if (buff == NULL)
 			return -EFAULT;
-		if (iocommand.Request.Type.Direction == XFER_WRITE) {
+		if (iocommand.Request.Type.Direction & XFER_WRITE) {
 			/* Copy the data into the buffer we created */
 			if (copy_from_user(buff, iocommand.buf,
 				iocommand.buf_size)) {
@@ -2597,7 +2607,7 @@ static int hpsa_passthru_ioctl(struct ctlr_info *h, void __user *argp)
 		cmd_special_free(h, c);
 		return -EFAULT;
 	}
-	if (iocommand.Request.Type.Direction == XFER_READ &&
+	if ((iocommand.Request.Type.Direction & XFER_READ) &&
 		iocommand.buf_size > 0) {
 		/* Copy the data out of the buffer we created */
 		if (copy_to_user(iocommand.buf, buff, iocommand.buf_size)) {
@@ -2673,7 +2683,7 @@ static int hpsa_big_passthru_ioctl(struct ctlr_info *h, void __user *argp)
 			status = -ENOMEM;
 			goto cleanup1;
 		}
-		if (ioc->Request.Type.Direction == XFER_WRITE) {
+		if (ioc->Request.Type.Direction & XFER_WRITE) {
 			if (copy_from_user(buff[sg_used], data_ptr, sz)) {
 				status = -ENOMEM;
 				goto cleanup1;
@@ -2718,7 +2728,7 @@ static int hpsa_big_passthru_ioctl(struct ctlr_info *h, void __user *argp)
 		status = -EFAULT;
 		goto cleanup1;
 	}
-	if (ioc->Request.Type.Direction == XFER_READ && ioc->buf_size > 0) {
+	if ((ioc->Request.Type.Direction & XFER_READ) && ioc->buf_size > 0) {
 		/* Copy the data out of the buffer we created */
 		BYTE __user *ptr = ioc->buf;
 		for (i = 0; i < sg_used; i++) {
@@ -3287,6 +3297,31 @@ static int hpsa_controller_hard_reset(struct pci_dev *pdev,
 	return 0;
 }
 
+static int hpsa_wait_for_board_state(struct pci_dev *pdev,
+	void __iomem *vaddr, int wait_for_ready)
+{
+	int i, iterations;
+	u32 scratchpad;
+	if (wait_for_ready)
+		iterations = HPSA_BOARD_READY_ITERATIONS;
+	else
+		iterations = HPSA_BOARD_NOT_READY_ITERATIONS;
+
+	for (i = 0; i < iterations; i++) {
+		scratchpad = readl(vaddr + SA5_SCRATCHPAD_OFFSET);
+		if (wait_for_ready) {
+			if (scratchpad == HPSA_FIRMWARE_READY)
+				return 0;
+		} else {
+			if (scratchpad != HPSA_FIRMWARE_READY)
+				return 0;
+		}
+		msleep(HPSA_BOARD_READY_POLL_INTERVAL_MSECS);
+	}
+	dev_warn(&pdev->dev, "board not ready, timed out.\n");
+	return -ENODEV;
+}
+
 static __devinit void init_driver_version(char *driver_version, int len)
 {
 	memset(driver_version, 0, len);
@@ -3322,7 +3357,6 @@ static __devinit void read_driver_ver_from_cfgtable(
 static __devinit int controller_reset_failed(
 	struct CfgTable __iomem *cfgtable)
 {
-
 	char *driver_ver, *old_driver_ver;
 	int rc, size = sizeof(cfgtable->driver_version);
 
@@ -3443,8 +3477,13 @@ static __devinit int hpsa_kdump_hard_reset_controller(struct pci_dev *pdev)
 	pci_write_config_word(pdev, 4, command_register);
 
 	/* Some devices (notably the HP Smart Array 5i Controller)
-	   need a little pause here */
-	msleep(HPSA_POST_RESET_PAUSE_MSECS);
+	 * need a little pause here.  Not all controllers though,
+	 * and for some we will miss the transition to NOT READY
+	 * if we wait here.   As a heuristic, if either doorbell
+	 * reset method is supported, we'll skip this sleep.
+	 */
+	if (!use_doorbell)
+		msleep(HPSA_POST_RESET_PAUSE_MSECS);
 
 	/* Wait for board to become not ready, then ready. */
 	dev_info(&pdev->dev, "Waiting for board to reset.\n");
@@ -3608,6 +3647,16 @@ default_int_mode:
 	h->intr[h->intr_mode] = h->pdev->irq;
 }
 
+int (*hpsa_alternate_pci_init)(struct ctlr_info *h,
+	struct pci_dev *pdev, u32 board_id, void *intr, void *remove);
+/* ^^^ note, since pdev and board_id are already in h, look into
+ * removing the pdev and board_id parameters.  However the Ibanez
+ * hpsa_alternate_pci_init function does some funny things, so it's
+ * not immediately clear to me that removing these is perfectly
+ * straightforward.  Also I renamed this function hpsa_alternate_pci_init
+ * (previously just alternate_pci_init) since we export it.
+ */
+EXPORT_SYMBOL(hpsa_alternate_pci_init);
 static int __devinit hpsa_lookup_board_id(struct pci_dev *pdev, u32 *board_id)
 {
 	int i;
@@ -3625,9 +3674,15 @@ static int __devinit hpsa_lookup_board_id(struct pci_dev *pdev, u32 *board_id)
 	if ((subsystem_vendor_id != PCI_VENDOR_ID_HP &&
 		subsystem_vendor_id != PCI_VENDOR_ID_COMPAQ) ||
 		!hpsa_allow_any) {
-		dev_warn(&pdev->dev, "unrecognized board ID: "
-			"0x%08x, ignoring.\n", *board_id);
-			return -ENODEV;
+		/* Ibanez check */
+		if ((subsystem_vendor_id != 0x1000) &&
+		    (subsystem_vendor_id != 0x1590) &&
+		    (subsystem_vendor_id != 0x103c) &&
+		    (*board_id != 0x1783103c)) {
+			dev_warn(&pdev->dev, "unrecognized board ID: "
+				"0x%08x, ignoring.\n", *board_id);
+				return -ENODEV;
+		}
 	}
 	return ARRAY_SIZE(products) - 1; /* generic unknown smart array */
 }
@@ -3657,31 +3712,6 @@ static int __devinit hpsa_pci_find_memory_BAR(struct pci_dev *pdev,
 	return -ENODEV;
 }
 
-static int __devinit hpsa_wait_for_board_state(struct pci_dev *pdev,
-	void __iomem *vaddr, int wait_for_ready)
-{
-	int i, iterations;
-	u32 scratchpad;
-	if (wait_for_ready)
-		iterations = HPSA_BOARD_READY_ITERATIONS;
-	else
-		iterations = HPSA_BOARD_NOT_READY_ITERATIONS;
-
-	for (i = 0; i < iterations; i++) {
-		scratchpad = readl(vaddr + SA5_SCRATCHPAD_OFFSET);
-		if (wait_for_ready) {
-			if (scratchpad == HPSA_FIRMWARE_READY)
-				return 0;
-		} else {
-			if (scratchpad != HPSA_FIRMWARE_READY)
-				return 0;
-		}
-		msleep(HPSA_BOARD_READY_POLL_INTERVAL_MSECS);
-	}
-	dev_warn(&pdev->dev, "board not ready, timed out.\n");
-	return -ENODEV;
-}
-
 static int __devinit hpsa_find_cfg_addrs(struct pci_dev *pdev,
 	void __iomem *vaddr, u32 *cfg_base_addr, u64 *cfg_base_addr_index,
 	u64 *cfg_offset)
@@ -3715,7 +3745,7 @@ static int __devinit hpsa_find_cfgtables(struct ctlr_info *h)
 		return -ENOMEM;
 	rc = write_driver_ver_to_cfgtable(h->cfgtable);
 	if (rc)
-		return rc;
+		return -ENOMEM;
 	/* Find performant mode table. */
 	trans_offset = readl(&h->cfgtable->TransMethodOffset);
 	h->transtable = remap_pci_mem(pci_resource_start(h->pdev,
@@ -3849,6 +3879,8 @@ static int __devinit hpsa_enter_simple_mode(struct ctlr_info *h)
 	return 0;
 }
 
+static void __devexit hpsa_remove_one(struct pci_dev *pdev);
+
 static int __devinit hpsa_pci_init(struct ctlr_info *h)
 {
 	int prod_index, err;
@@ -3856,6 +3888,11 @@ static int __devinit hpsa_pci_init(struct ctlr_info *h)
 	prod_index = hpsa_lookup_board_id(h->pdev, &h->board_id);
 	if (prod_index < 0)
 		return -ENODEV;
+
+	// Skip over sabine.
+	if ((h->board_id == 0x1783103c) || (h->board_id == 0x005f1590))
+		return -ENODEV;
+
 	h->product_name = products[prod_index].product_name;
 	h->access = *(products[prod_index].access);
 
@@ -3875,7 +3912,23 @@ static int __devinit hpsa_pci_init(struct ctlr_info *h)
 			"cannot obtain PCI resources, aborting\n");
 		return err;
 	}
+
+	if (hpsa_alternate_pci_init) {
+		h->intr_mode = SIMPLE_MODE_INT;
+		err = hpsa_alternate_pci_init(h, h->pdev, h->board_id,
+				do_hpsa_intr_msi, hpsa_remove_one);
+		if (err < 0)
+			goto err_out_free_res;
+		/* If 1 it's a real Smart Array HBA, we want to continue on. */
+		if (err != 1) {
+			/* init is done for this IBANEZ board (i.e. an ICH10) */
+			return err;
+		}
+
+	}
+
 	hpsa_interrupt_mode(h);
+
 	err = hpsa_pci_find_memory_BAR(h->pdev, &h->paddr);
 	if (err)
 		goto err_out_free_res;
@@ -4011,7 +4064,8 @@ static int hpsa_request_irq(struct ctlr_info *h,
 				IRQF_DISABLED, h->devname, h);
 	else
 		rc = request_irq(h->intr[h->intr_mode], intxhandler,
-				IRQF_DISABLED, h->devname, h);
+				h->software_raid ? IRQF_SHARED : IRQF_DISABLED,
+				h->devname, h);
 	if (rc) {
 		dev_err(&h->pdev->dev, "unable to get irq %d for %s\n",
 		       h->intr[h->intr_mode], h->devname);
@@ -4104,7 +4158,7 @@ reinit_after_soft_reset:
 		return -ENOMEM;
 
 	h->pdev = pdev;
-	h->busy_initializing = 1;
+	h->busy_initializing = BUSY_INIT_BUSY;
 	h->intr_mode = hpsa_simple_mode ? SIMPLE_MODE_INT : PERF_MODE_INT;
 	INIT_LIST_HEAD(&h->cmpQ);
 	INIT_LIST_HEAD(&h->reqQ);
@@ -4213,7 +4267,7 @@ reinit_after_soft_reset:
 
 	hpsa_hba_inquiry(h);
 	hpsa_register_scsi(h);	/* hook ourselves into SCSI subsystem */
-	h->busy_initializing = 0;
+	h->busy_initializing = BUSY_INIT_IDLE;
 	return 1;
 
 clean4:
@@ -4222,10 +4276,11 @@ clean4:
 	free_irq(h->intr[h->intr_mode], h);
 clean2:
 clean1:
-	h->busy_initializing = 0;
+	h->busy_initializing = BUSY_INIT_IDLE;
 	kfree(h);
 	return rc;
 }
+EXPORT_SYMBOL(hpsa_init_one);
 
 static void hpsa_flush_cache(struct ctlr_info *h)
 {
@@ -4262,13 +4317,20 @@ static void hpsa_shutdown(struct pci_dev *pdev)
 	 * To write all data in the battery backed cache to disks
 	 */
 	hpsa_flush_cache(h);
+	h->busy_initializing = BUSY_INIT_SHUTDOWN;
 	h->access.set_intr_mask(h, HPSA_INTR_OFF);
-	free_irq(h->intr[h->intr_mode], h);
+	if (h->intr[h->intr_mode] != 0)
+	    free_irq(h->intr[h->intr_mode], h);
 #ifdef CONFIG_PCI_MSI
-	if (h->msix_vector)
-		pci_disable_msix(h->pdev);
-	else if (h->msi_vector)
-		pci_disable_msi(h->pdev);
+	if (h->msix_vector) {
+		if (h->pdev->msix_enabled) {
+			pci_disable_msix(h->pdev);
+		}
+	} else if (h->msi_vector) {
+		if (h->pdev->msi_enabled) {
+			pci_disable_msi(h->pdev);
+		}
+	}
 #endif				/* CONFIG_PCI_MSI */
 }
 
@@ -4281,6 +4343,12 @@ static void __devexit hpsa_remove_one(struct pci_dev *pdev)
 		return;
 	}
 	h = pci_get_drvdata(pdev);
+
+	if ((h->board_id == 0x1783103c) || (h->board_id == 0x005f1590)) {
+		printk("%s: Not processing board 0x%02x\n", __func__, h->board_id);
+		return;
+	}
+
 	hpsa_unregister_scsi(h);	/* unhook from SCSI subsystem */
 	hpsa_shutdown(pdev);
 	iounmap(h->vaddr);
@@ -4293,8 +4361,9 @@ static void __devexit hpsa_remove_one(struct pci_dev *pdev)
 	pci_free_consistent(h->pdev,
 		h->nr_cmds * sizeof(struct ErrorInfo),
 		h->errinfo_pool, h->errinfo_pool_dhandle);
-	pci_free_consistent(h->pdev, h->reply_pool_size,
-		h->reply_pool, h->reply_pool_dhandle);
+	if (h->intr_mode != SIMPLE_MODE_INT)
+		pci_free_consistent(h->pdev, h->reply_pool_size,
+			h->reply_pool, h->reply_pool_dhandle);
 	kfree(h->cmd_pool_bits);
 	kfree(h->blockFetchTable);
 	kfree(h->hba_inquiry_data);
@@ -4433,7 +4502,7 @@ static __devinit void hpsa_put_ctlr_into_performant_mode(struct ctlr_info *h)
 {
 	u32 trans_support;
 
-	if (hpsa_simple_mode)
+	if (h->intr_mode == SIMPLE_MODE_INT)
 		return;
 
 	trans_support = readl(&(h->cfgtable->TransportSupport));
diff --git a/drivers/scsi/hpsa.h b/drivers/scsi/hpsa.h
index 7f53cea..778d080 100644
--- a/drivers/scsi/hpsa.h
+++ b/drivers/scsi/hpsa.h
@@ -35,6 +35,8 @@ struct access_method {
 	unsigned long (*fifo_full)(struct ctlr_info *h);
 	bool (*intr_pending)(struct ctlr_info *h);
 	unsigned long (*command_completed)(struct ctlr_info *h);
+	unsigned long (*lock)(struct ctlr_info *h);
+	void (*unlock)(struct ctlr_info *h, unsigned long flags);
 };
 
 struct hpsa_scsi_dev_t {
@@ -60,7 +62,7 @@ struct ctlr_info {
 	struct CfgTable __iomem *cfgtable;
 	int     max_sg_entries;
 	int	interrupts_enabled;
-	int	major;
+	int	software_raid;
 	int 	max_commands;
 	int	commands_outstanding;
 	int 	max_outstanding; /* Debug */
@@ -96,6 +98,9 @@ struct ctlr_info {
 	int			nr_allocs;
 	int			nr_frees;
 	int			busy_initializing;
+#define BUSY_INIT_IDLE 0
+#define BUSY_INIT_BUSY 1
+#define BUSY_INIT_SHUTDOWN 2
 	int			busy_scanning;
 	int			scan_finished;
 	spinlock_t		scan_lock;
@@ -157,7 +162,7 @@ struct ctlr_info {
  * HPSA_BOARD_READY_ITERATIONS are derived from those.
  */
 #define HPSA_BOARD_READY_WAIT_SECS (120)
-#define HPSA_BOARD_NOT_READY_WAIT_SECS (100)
+#define HPSA_BOARD_NOT_READY_WAIT_SECS (120)
 #define HPSA_BOARD_READY_POLL_INTERVAL_MSECS (100)
 #define HPSA_BOARD_READY_POLL_INTERVAL \
 	((HPSA_BOARD_READY_POLL_INTERVAL_MSECS * HZ) / 1000)
@@ -320,6 +325,22 @@ static unsigned long SA5_completed(struct ctlr_info *h)
 
 	return register_value;
 }
+
+/*
+ * Does controller specific locking for submits
+ */
+static unsigned long SA5_lock(struct ctlr_info *h)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&h->lock, flags);
+	return flags;
+}
+
+static void SA5_unlock(struct ctlr_info *h, unsigned long flags)
+{
+	spin_unlock_irqrestore(&h->lock, flags);
+}
 /*
  *	Returns true if an interrupt is pending..
  */
@@ -352,6 +373,8 @@ static struct access_method SA5_access = {
 	SA5_fifo_full,
 	SA5_intr_pending,
 	SA5_completed,
+	SA5_lock,
+	SA5_unlock,
 };
 
 static struct access_method SA5_performant_access = {
@@ -360,6 +383,8 @@ static struct access_method SA5_performant_access = {
 	SA5_fifo_full,
 	SA5_performant_intr_pending,
 	SA5_performant_completed,
+	SA5_lock,
+	SA5_unlock,
 };
 
 struct board_type {
diff --git a/drivers/scsi/hpsa_cmd.h b/drivers/scsi/hpsa_cmd.h
index 55d741b..518d613 100644
--- a/drivers/scsi/hpsa_cmd.h
+++ b/drivers/scsi/hpsa_cmd.h
@@ -257,6 +257,14 @@ struct ErrorInfo {
 #define CMD_IOCTL_PEND  0x01
 #define CMD_SCSI	0x03
 
+/* This structure needs to be divisible by 32 for new
+ * indexing method and performant mode.
+ */
+#define PAD32 32
+#define PAD64DIFF 0
+#define USEEXTRA ((sizeof(void *) - 4)/4)
+#define PADSIZE (PAD32 + PAD64DIFF * USEEXTRA)
+
 #define DIRECT_LOOKUP_SHIFT 5
 #define DIRECT_LOOKUP_BIT 0x10
 #define DIRECT_LOOKUP_MASK (~((1 << DIRECT_LOOKUP_SHIFT) - 1))
