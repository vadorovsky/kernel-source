From: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Date: Thu, 28 Mar 2013 13:59:52 +0530
Subject: qla4xxx: Use correct flash ddb offset for ISP40XX
References: FATE#313902 bnc#814640
Patch-mainline: Submitted: 4/5/2013 linux-scsi

Use correct flash ddb offset to add and delete flash target
entries for ISP40XX

Signed-off-by: Adheer Chandravanshi <adheer.chandravanshi@qlogic.com>
Signed-off-by: Vikas Chaudhary <vikas.chaudhary@qlogic.com>
Reviewed-by: Mike Christie <michaelc@cs.wisc.edu>
Acked-by: Lee Duncan <lduncan@suse.com>
---
 drivers/scsi/qla4xxx/ql4_mbx.c |  7 ++++--
 drivers/scsi/qla4xxx/ql4_os.c  | 57 ++++++++++++++++++++++++++++--------------
 2 files changed, 43 insertions(+), 21 deletions(-)

diff --git a/drivers/scsi/qla4xxx/ql4_mbx.c b/drivers/scsi/qla4xxx/ql4_mbx.c
index 8985997..a501bea 100644
--- a/drivers/scsi/qla4xxx/ql4_mbx.c
+++ b/drivers/scsi/qla4xxx/ql4_mbx.c
@@ -1421,7 +1421,7 @@ int qla4xxx_flashdb_by_index(struct scsi_qla_host *ha,
 			     struct dev_db_entry *fw_ddb_entry,
 			     dma_addr_t fw_ddb_entry_dma, uint16_t ddb_index)
 {
-	uint32_t dev_db_start_offset = FLASH_OFFSET_DB_INFO;
+	uint32_t dev_db_start_offset;
 	uint32_t dev_db_end_offset;
 	int status = QLA_ERROR;
 
@@ -1429,6 +1429,7 @@ int qla4xxx_flashdb_by_index(struct scsi_qla_host *ha,
 
 	if (is_qla40XX(ha)) {
 		dev_db_start_offset = FLASH_OFFSET_DB_INFO;
+		dev_db_end_offset = FLASH_OFFSET_DB_END;
 	} else {
 		dev_db_start_offset = FLASH_RAW_ACCESS_ADDR +
 				      (ha->hw.flt_region_ddb << 2);
@@ -1437,9 +1438,11 @@ int qla4xxx_flashdb_by_index(struct scsi_qla_host *ha,
 		 */
 		if (ha->port_num == 1)
 			dev_db_start_offset += (ha->hw.flt_ddb_size / 2);
+
+		dev_db_end_offset = dev_db_start_offset +
+				    (ha->hw.flt_ddb_size / 2);
 	}
 
-	dev_db_end_offset = dev_db_start_offset + (ha->hw.flt_ddb_size / 2);
 	dev_db_start_offset += (ddb_index * sizeof(*fw_ddb_entry));
 
 	if (dev_db_start_offset > dev_db_end_offset) {
diff --git a/drivers/scsi/qla4xxx/ql4_os.c b/drivers/scsi/qla4xxx/ql4_os.c
index 7627ec3..d7a029b 100644
--- a/drivers/scsi/qla4xxx/ql4_os.c
+++ b/drivers/scsi/qla4xxx/ql4_os.c
@@ -6583,6 +6583,8 @@ static int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)
 	struct dev_db_entry *fw_ddb_entry = NULL;
 	dma_addr_t fw_ddb_entry_dma;
 	uint16_t *ddb_cookie = NULL;
+	size_t ddb_size;
+	void *pddb = NULL;
 	int target_id;
 	int rc = 0;
 
@@ -6602,18 +6604,12 @@ static int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)
 	if (fnode_sess->flash_state == DEV_DB_NON_PERSISTENT)
 		goto sysfs_ddb_del;
 
-	ddb_cookie = dma_alloc_coherent(&ha->pdev->dev, sizeof(*ddb_cookie),
-					&fw_ddb_entry_dma, GFP_KERNEL);
-	if (!ddb_cookie) {
-		rc = -ENOMEM;
-		DEBUG2(ql4_printk(KERN_ERR, ha,
-				  "%s: Unable to allocate dma buffer\n",
-				  __func__));
-		goto exit_ddb_del;
-	}
-
 	if (is_qla40XX(ha)) {
 		dev_db_start_offset = FLASH_OFFSET_DB_INFO;
+		dev_db_end_offset = FLASH_OFFSET_DB_END;
+		dev_db_start_offset += (fnode_sess->target_id *
+				       sizeof(*fw_ddb_entry));
+		ddb_size = sizeof(*fw_ddb_entry);
 	} else {
 		dev_db_start_offset = FLASH_RAW_ACCESS_ADDR +
 				      (ha->hw.flt_region_ddb << 2);
@@ -6622,12 +6618,17 @@ static int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)
 		 */
 		if (ha->port_num == 1)
 			dev_db_start_offset += (ha->hw.flt_ddb_size / 2);
-	}
 
-	dev_db_end_offset = dev_db_start_offset + (ha->hw.flt_ddb_size / 2);
-	dev_db_start_offset += (fnode_sess->target_id * sizeof(*fw_ddb_entry));
-	dev_db_start_offset += (void *)&(fw_ddb_entry->cookie) -
-			       (void *)fw_ddb_entry;
+		dev_db_end_offset = dev_db_start_offset +
+				    (ha->hw.flt_ddb_size / 2);
+
+		dev_db_start_offset += (fnode_sess->target_id *
+				       sizeof(*fw_ddb_entry));
+		dev_db_start_offset += (void *)&(fw_ddb_entry->cookie) -
+				       (void *)fw_ddb_entry;
+
+		ddb_size = sizeof(*ddb_cookie);
+	}
 
 	DEBUG2(ql4_printk(KERN_ERR, ha, "%s: start offset=%u, end offset=%u\n",
 			  __func__, dev_db_start_offset, dev_db_end_offset));
@@ -6639,10 +6640,28 @@ static int qla4xxx_sysfs_ddb_delete(struct iscsi_bus_flash_session *fnode_sess)
 		goto exit_ddb_del;
 	}
 
+	pddb = dma_alloc_coherent(&ha->pdev->dev, ddb_size,
+				  &fw_ddb_entry_dma, GFP_KERNEL);
+	if (!pddb) {
+		rc = -ENOMEM;
+		DEBUG2(ql4_printk(KERN_ERR, ha,
+				  "%s: Unable to allocate dma buffer\n",
+				  __func__));
+		goto exit_ddb_del;
+	}
+
+	if (is_qla40XX(ha)) {
+		fw_ddb_entry = pddb;
+		memset(fw_ddb_entry, 0, ddb_size);
+		ddb_cookie = &fw_ddb_entry->cookie;
+	} else {
+		ddb_cookie = pddb;
+	}
+
 	/* invalidate the cookie */
 	*ddb_cookie = 0xFFEE;
 	qla4xxx_set_flash(ha, fw_ddb_entry_dma, dev_db_start_offset,
-			  sizeof(*ddb_cookie), FLASH_OPT_RMW_COMMIT);
+			  ddb_size, FLASH_OPT_RMW_COMMIT);
 
 sysfs_ddb_del:
 	target_id = fnode_sess->target_id;
@@ -6651,9 +6670,9 @@ sysfs_ddb_del:
 		   "%s: session and conn entries for flashnode %u of host %lu deleted\n",
 		   __func__, target_id, ha->host_no);
 exit_ddb_del:
-	if (ddb_cookie)
-		dma_free_coherent(&ha->pdev->dev, sizeof(*ddb_cookie),
-				  ddb_cookie, fw_ddb_entry_dma);
+	if (pddb)
+		dma_free_coherent(&ha->pdev->dev, ddb_size, pddb,
+				  fw_ddb_entry_dma);
 	return rc;
 }
 

