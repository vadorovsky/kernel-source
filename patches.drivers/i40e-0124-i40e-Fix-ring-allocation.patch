From: Neerav Parikh <Neerav.Parikh@intel.com>
Date: Thu, 28 Nov 2013 06:39:37 +0000
Subject: [PATCH v3 124/474] i40e: Fix ring allocation
Patch-mainline: v3.14-rc1
Git-commit: d739764406ee70e46e890db458fedd17708ee7bc
References: bsc#909484 FATE#317397

The allocation and clearing of rings for a VSI should be
using the alloc_queue_pairs and not num_queue_pairs.

The alloc_queue_pairs per VSI is a pre-allocated number
of queues assigned to a VSI; based on number of TCs enabled
only certain number of queues may be used from that. This
is mainly valid only for the LAN VSI case as that is the
only VSI that may be enabled with multiple traffic classes.
In the future the number of TCs may change based on DCBX
configuration.

The actual number of queues that are enabled/configured is
based on the number of TCs enabled for a given VSI and that
is stored in num_queue_pairs.

With this change num_[tr]x_queues is unused so remove them.

Change-Id: I9c2f84778bb25f7313c630e9b002a0caa883ce29
Signed-off-by: Neerav Parikh <Neerav.Parikh@intel.com>
Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
Tested-by: Kavindya Deegala <kavindya.s.deegala@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/intel/i40e/i40e.h      |    3 ---
 drivers/net/ethernet/intel/i40e/i40e_main.c |   14 ++++----------
 2 files changed, 4 insertions(+), 13 deletions(-)

--- a/drivers/net/ethernet/intel/i40e/i40e.h
+++ b/drivers/net/ethernet/intel/i40e/i40e.h
@@ -249,9 +249,6 @@ struct i40e_pf {
 #define I40E_FLAG_VXLAN_FILTER_SYNC            (u64)(1 << 27)
 #endif
 
-	u16 num_tx_queues;
-	u16 num_rx_queues;
-
 	bool stat_offsets_loaded;
 	struct i40e_hw_port_stats stats;
 	struct i40e_hw_port_stats stats_offsets;
--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -3975,11 +3975,11 @@ static int i40e_open(struct net_device *
 		goto err_setup_rx;
 
 	/* Notify the stack of the actual queue counts. */
-	err = netif_set_real_num_tx_queues(netdev, pf->num_tx_queues);
+	err = netif_set_real_num_tx_queues(netdev, vsi->num_queue_pairs);
 	if (err)
 		goto err_set_queues;
 
-	err = netif_set_real_num_rx_queues(netdev, pf->num_rx_queues);
+	err = netif_set_real_num_rx_queues(netdev, vsi->num_queue_pairs);
 	if (err)
 		goto err_set_queues;
 
@@ -5358,7 +5358,7 @@ static void i40e_vsi_clear_rings(struct
 	int i;
 
 	if (vsi->tx_rings[0]) {
-		for (i = 0; i < vsi->num_queue_pairs; i++) {
+		for (i = 0; i < vsi->alloc_queue_pairs; i++) {
 			kfree_rcu(vsi->tx_rings[i], rcu);
 			vsi->tx_rings[i] = NULL;
 			vsi->rx_rings[i] = NULL;
@@ -5376,7 +5376,7 @@ static int i40e_alloc_rings(struct i40e_
 	int i;
 
 	/* Set basic values in the rings to be used later during open() */
-	for (i = 0; i < vsi->num_queue_pairs; i++) {
+	for (i = 0; i < vsi->alloc_queue_pairs; i++) {
 		struct i40e_ring *tx_ring;
 		struct i40e_ring *rx_ring;
 
@@ -7216,12 +7216,6 @@ static int i40e_setup_pf_switch(struct i
 			i40e_fdir_teardown(pf);
 			return -EAGAIN;
 		}
-		/* accommodate kcompat by copying the main VSI queue count
-		 * into the pf, since this newer code pushes the pf queue
-		 * info down a level into a VSI
-		 */
-		pf->num_rx_queues = vsi->num_queue_pairs;
-		pf->num_tx_queues = vsi->num_queue_pairs;
 	} else {
 		/* force a reset of TC and queue layout configurations */
 		u8 enabled_tc = pf->vsi[pf->lan_vsi]->tc_config.enabled_tc;
