From: Mike Miller <mike.miller@hp.com>
Date: Fri, 1 Jul 2011 12:50:30 +0200
Subject: cciss: Update to version 4.6.28
References: FATE#311200,bnc#703422
Patch-Mainline: Not yet

This patch updates the cciss driver to versionn 4.6.28.

Signed-off-by: Mike Miller <mike.miller@hp.com>
Signed-off-by: Hannes Reinecke <hare@suse.de>
---
 drivers/block/cciss.c       |  395 ++++++++++++++++---------------------------
 drivers/block/cciss.h       |  155 +++++++++---------
 drivers/block/cciss_cmd.h   |   14 +-
 drivers/block/cciss_scsi.c  |  230 ++++++++++++-------------
 drivers/block/cciss_scsi.h  |   32 ++--
 include/linux/Kbuild        |    1 +
 include/linux/cciss_ioctl.h |    8 +-
 7 files changed, 360 insertions(+), 475 deletions(-)

diff --git a/drivers/block/cciss.c b/drivers/block/cciss.c
index e57cdaf..4b3e22b 100644
--- a/drivers/block/cciss.c
+++ b/drivers/block/cciss.c
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers.
- *    (C) Copyright 2000, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2000, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -26,6 +26,7 @@
 #include <linux/pci.h>
 #include <linux/kernel.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/delay.h>
 #include <linux/major.h>
 #include <linux/fs.h>
@@ -52,29 +53,29 @@
 #include <scsi/scsi_ioctl.h>
 #include <linux/cdrom.h>
 #include <linux/scatterlist.h>
-#include <linux/kthread.h>
+#include "cciss_cmd.h"
+#include "cciss.h"
+#include <linux/cciss_ioctl.h>
 
 #define CCISS_DRIVER_VERSION(maj,min,submin) ((maj<<16)|(min<<8)|(submin))
-#define DRIVER_NAME "HP CISS Driver (v 3.6.26)"
-#define DRIVER_VERSION CCISS_DRIVER_VERSION(3, 6, 26)
+#define DRIVER_NAME "HP CISS Driver (v 4.6.28)"
+#define DRIVER_VERSION CCISS_DRIVER_VERSION(4, 6, 28)
 
 /* Embedded module documentation macros - see modules.h */
 MODULE_AUTHOR("Hewlett-Packard Company");
 MODULE_DESCRIPTION("Driver for HP Smart Array Controllers");
 MODULE_SUPPORTED_DEVICE("HP Smart Array Controllers");
-MODULE_VERSION("3.6.26");
+MODULE_VERSION("4.6.28");
 MODULE_LICENSE("GPL");
 static int cciss_tape_cmds = 6;
 module_param(cciss_tape_cmds, int, 0644);
-MODULE_PARM_DESC(cciss_tape_cmds,
-	"number of commands to allocate for tape devices (default: 6)");
+MODULE_PARM_DESC(cciss_tape_cmds, "number of commands to allocate for tape devices (default: 6)");
 
-static DEFINE_MUTEX(cciss_mutex);
-static struct proc_dir_entry *proc_cciss;
-
-#include "cciss_cmd.h"
-#include "cciss.h"
-#include <linux/cciss_ioctl.h>
+static int cciss_allow_hpsa;
+module_param(cciss_allow_hpsa, int, S_IRUGO|S_IWUSR);
+MODULE_PARM_DESC(cciss_allow_hpsa,
+	"Prevent cciss driver from accessing hardware known to be "
+	" supported by the hpsa driver");
 
 /* define the PCI info for the cards we can control */
 static const struct pci_device_id cciss_pci_device_id[] = {
@@ -127,9 +128,7 @@ static struct board_type products[] = {
 	{0x3214103C, "Smart Array E200i", &SA5_access},
 	{0x3215103C, "Smart Array E200i", &SA5_access},
 	{0x3237103C, "Smart Array E500", &SA5_access},
-	{0x3223103C, "Smart Array P800", &SA5_access},
-	{0x3234103C, "Smart Array P400", &SA5_access},
-	{0x323D103C, "Smart Array P700m", &SA5_access},
+	{0x323d103c, "Smart Array P700M", &SA5_access},
 };
 
 /* How long to wait (in milliseconds) for board to go into simple mode */
@@ -146,18 +145,11 @@ static struct board_type products[] = {
 
 static ctlr_info_t *hba[MAX_CTLR];
 
-static struct task_struct *cciss_scan_thread;
-static DEFINE_MUTEX(scan_mutex);
-static LIST_HEAD(scan_q);
-
 static void do_cciss_request(struct request_queue *q);
 static irqreturn_t do_cciss_intx(int irq, void *dev_id);
 static irqreturn_t do_cciss_msix_intr(int irq, void *dev_id);
 static int cciss_open(struct block_device *bdev, fmode_t mode);
-static int cciss_unlocked_open(struct block_device *bdev, fmode_t mode);
 static int cciss_release(struct gendisk *disk, fmode_t mode);
-static int do_ioctl(struct block_device *bdev, fmode_t mode,
-		    unsigned int cmd, unsigned long arg);
 static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
 		       unsigned int cmd, unsigned long arg);
 static int cciss_getgeo(struct block_device *bdev, struct hd_geometry *geo);
@@ -184,14 +176,15 @@ static int sendcmd_withirq_core(ctlr_info_t *h, CommandList_struct *c,
 	int attempt_retry);
 static int process_sendcmd_error(ctlr_info_t *h, CommandList_struct *c);
 
-static int add_to_scan_list(struct ctlr_info *h);
-static int scan_thread(void *data);
+static void cciss_get_uid(ctlr_info_t *h, int logvol,
+				unsigned char *uid, int buflen);
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c);
 static void cciss_hba_release(struct device *dev);
 static void cciss_device_release(struct device *dev);
 static void cciss_free_gendisk(ctlr_info_t *h, int drv_index);
 static void cciss_free_drive_info(ctlr_info_t *h, int drv_index);
-static inline u32 next_command(ctlr_info_t *h);
+static inline void log_unit_to_scsi3addr(ctlr_info_t *h,
+	unsigned char scsi3addr[], uint32_t log_unit);
 static int __devinit cciss_find_cfg_addrs(struct pci_dev *pdev,
 	void __iomem *vaddr, u32 *cfg_base_addr, u64 *cfg_base_addr_index,
 	u64 *cfg_offset);
@@ -218,12 +211,14 @@ static void cciss_procinit(ctlr_info_t *h)
 static int cciss_compat_ioctl(struct block_device *, fmode_t,
 			      unsigned, unsigned long);
 #endif
+static void cciss_sysfs_stat_inquiry(ctlr_info_t *h, int logvol,
+			drive_info_struct *drv);
 
 static const struct block_device_operations cciss_fops = {
 	.owner = THIS_MODULE,
-	.open = cciss_unlocked_open,
+	.open = cciss_open,
 	.release = cciss_release,
-	.ioctl = do_ioctl,
+	.locked_ioctl = cciss_ioctl,
 	.getgeo = cciss_getgeo,
 #ifdef CONFIG_COMPAT
 	.compat_ioctl = cciss_compat_ioctl,
@@ -359,7 +354,7 @@ static void cciss_map_sg_chain_block(ctlr_info_t *h, CommandList_struct *c,
 static const char *raid_label[] = { "0", "4", "1(1+0)", "5", "5+1", "ADG",
 	"UNKNOWN"
 };
-#define RAID_UNKNOWN (ARRAY_SIZE(raid_label)-1)
+#define RAID_UNKNOWN (sizeof(raid_label) / sizeof(raid_label[0])-1)
 
 #ifdef CONFIG_PROC_FS
 
@@ -370,6 +365,8 @@ static const char *raid_label[] = { "0", "4", "1(1+0)", "5", "5+1", "ADG",
 #define ENG_GIG_FACTOR (ENG_GIG/512)
 #define ENGAGE_SCSI	"engage scsi"
 
+static struct proc_dir_entry *proc_cciss;
+
 static void cciss_seq_show_header(struct seq_file *seq)
 {
 	ctlr_info_t *h = seq->private;
@@ -557,8 +554,6 @@ static void __devinit cciss_procinit(ctlr_info_t *h)
 }
 #endif				/* CONFIG_PROC_FS */
 
-#define MAX_PRODUCT_NAME_LEN 19
-
 #define to_hba(n) container_of(n, struct ctlr_info, dev)
 #define to_drv(n) container_of(n, drive_info_struct, dev)
 
@@ -622,6 +617,7 @@ static ssize_t host_show_resettable(struct device *dev,
 }
 static DEVICE_ATTR(resettable, S_IRUGO, host_show_resettable, NULL);
 
+#if 0
 static ssize_t host_store_rescan(struct device *dev,
 				 struct device_attribute *attr,
 				 const char *buf, size_t count)
@@ -635,6 +631,7 @@ static ssize_t host_store_rescan(struct device *dev,
 	return count;
 }
 static DEVICE_ATTR(rescan, S_IWUSR, NULL, host_store_rescan);
+#endif /* mfm need to do something else in sysfs */
 
 static ssize_t dev_show_unique_id(struct device *dev,
 				 struct device_attribute *attr,
@@ -650,7 +647,7 @@ static ssize_t dev_show_unique_id(struct device *dev,
 	if (h->busy_configuring)
 		ret = -EBUSY;
 	else
-		memcpy(sn, drv->serial_no, sizeof(sn));
+		memcpy(sn, drv->uid, sizeof(sn));
 	spin_unlock_irqrestore(&h->lock, flags);
 
 	if (ret)
@@ -806,7 +803,9 @@ static ssize_t cciss_show_usage_count(struct device *dev,
 static DEVICE_ATTR(usage_count, S_IRUGO, cciss_show_usage_count, NULL);
 
 static struct attribute *cciss_host_attrs[] = {
+#if 0
 	&dev_attr_rescan.attr,
+#endif
 	&dev_attr_resettable.attr,
 	NULL
 };
@@ -822,8 +821,8 @@ static const struct attribute_group *cciss_host_attr_groups[] = {
 
 static struct device_type cciss_host_type = {
 	.name		= "cciss_host",
-	.groups		= cciss_host_attr_groups,
 	.release	= cciss_hba_release,
+	.groups		= cciss_host_attr_groups,
 };
 
 static struct attribute *cciss_dev_attrs[] = {
@@ -1039,9 +1038,9 @@ static void cmd_special_free(ctlr_info_t *h, CommandList_struct *c)
 	temp64.val32.lower = c->ErrDesc.Addr.lower;
 	temp64.val32.upper = c->ErrDesc.Addr.upper;
 	pci_free_consistent(h->pdev, sizeof(ErrorInfo_struct),
-			    c->err_info, (dma_addr_t) temp64.val);
-	pci_free_consistent(h->pdev, sizeof(CommandList_struct), c,
-		(dma_addr_t) cciss_tag_discard_error_bits(h, (u32) c->busaddr));
+		c->err_info, (dma_addr_t) temp64.val);
+	pci_free_consistent(h->pdev, sizeof(CommandList_struct),
+		c, (dma_addr_t) cciss_tag_discard_error_bits(h, (u32) c->busaddr));
 }
 
 static inline ctlr_info_t *get_host(struct gendisk *disk)
@@ -1092,47 +1091,31 @@ static int cciss_open(struct block_device *bdev, fmode_t mode)
 	return 0;
 }
 
-static int cciss_unlocked_open(struct block_device *bdev, fmode_t mode)
-{
-	int ret;
-
-	mutex_lock(&cciss_mutex);
-	ret = cciss_open(bdev, mode);
-	mutex_unlock(&cciss_mutex);
-
-	return ret;
-}
-
 /*
  * Close.  Sync first.
  */
 static int cciss_release(struct gendisk *disk, fmode_t mode)
 {
-	ctlr_info_t *h;
-	drive_info_struct *drv;
-
-	mutex_lock(&cciss_mutex);
-	h = get_host(disk);
-	drv = get_drv(disk);
+	ctlr_info_t *h = get_host(disk);
+	drive_info_struct *drv = get_drv(disk);
 	dev_dbg(&h->pdev->dev, "cciss_release %s\n", disk->disk_name);
 	drv->usage_count--;
 	h->usage_count--;
-	mutex_unlock(&cciss_mutex);
 	return 0;
 }
 
+#ifdef CONFIG_COMPAT
+
 static int do_ioctl(struct block_device *bdev, fmode_t mode,
 		    unsigned cmd, unsigned long arg)
 {
 	int ret;
-	mutex_lock(&cciss_mutex);
+	lock_kernel();
 	ret = cciss_ioctl(bdev, mode, cmd, arg);
-	mutex_unlock(&cciss_mutex);
+	unlock_kernel();
 	return ret;
 }
 
-#ifdef CONFIG_COMPAT
-
 static int cciss_ioctl32_passthru(struct block_device *bdev, fmode_t mode,
 				  unsigned cmd, unsigned long arg);
 static int cciss_ioctl32_big_passthru(struct block_device *bdev, fmode_t mode,
@@ -1179,6 +1162,7 @@ static int cciss_ioctl32_passthru(struct block_device *bdev, fmode_t mode,
 	int err;
 	u32 cp;
 
+	memset(&arg64, 0, sizeof(arg64));
 	err = 0;
 	err |=
 	    copy_from_user(&arg64.LUN_info, &arg32->LUN_info,
@@ -1452,20 +1436,17 @@ static int cciss_passthru(ctlr_info_t *h, void __user *argp)
 	if (!capable(CAP_SYS_RAWIO))
 		return -EPERM;
 
-	if (copy_from_user
-	    (&iocommand, argp, sizeof(IOCTL_Command_struct)))
+	if (copy_from_user(&iocommand, argp, sizeof(IOCTL_Command_struct)))
 		return -EFAULT;
 	if ((iocommand.buf_size < 1) &&
-	    (iocommand.Request.Type.Direction != XFER_NONE)) {
+	    (iocommand.Request.Type.Direction != XFER_NONE))
 		return -EINVAL;
-	}
 	if (iocommand.buf_size > 0) {
 		buff = kmalloc(iocommand.buf_size, GFP_KERNEL);
 		if (buff == NULL)
 			return -EFAULT;
 	}
 	if (iocommand.Request.Type.Direction == XFER_WRITE) {
-		/* Copy the data into the buffer we created */
 		if (copy_from_user(buff, iocommand.buf, iocommand.buf_size)) {
 			kfree(buff);
 			return -EFAULT;
@@ -1478,8 +1459,7 @@ static int cciss_passthru(ctlr_info_t *h, void __user *argp)
 		kfree(buff);
 		return -ENOMEM;
 	}
-	/* Fill in the command type */
-	c->cmd_type = CMD_IOCTL_PEND;
+	c->cmd_type = CMD_IOCTL_PEND; /* Fill in the command type */
 	/* Fill in Command Header */
 	c->Header.ReplyQueue = 0;   /* unused in simple mode */
 	if (iocommand.buf_size > 0) { /* buffer to fill */
@@ -1490,11 +1470,8 @@ static int cciss_passthru(ctlr_info_t *h, void __user *argp)
 		c->Header.SGTotal = 0;
 	}
 	c->Header.LUN = iocommand.LUN_info;
-	/* use the kernel address the cmd block for tag */
-	c->Header.Tag.lower = c->busaddr;
-
-	/* Fill in Request block */
-	c->Request = iocommand.Request;
+	c->Header.Tag.lower = c->busaddr; /* use bus addr for tag */
+	c->Request = iocommand.Request; /* Fill in Request block */
 
 	/* Fill in the scatter gather information */
 	if (iocommand.buf_size > 0) {
@@ -1503,18 +1480,19 @@ static int cciss_passthru(ctlr_info_t *h, void __user *argp)
 		c->SG[0].Addr.lower = temp64.val32.lower;
 		c->SG[0].Addr.upper = temp64.val32.upper;
 		c->SG[0].Len = iocommand.buf_size;
-		c->SG[0].Ext = 0;  /* we are not chaining */
+		c->SG[0].Ext = 0; /* we are not chaining */
 	}
 	c->waiting = &wait;
 
 	enqueue_cmd_and_start_io(h, c);
 	wait_for_completion(&wait);
 
-	/* unlock the buffers from DMA */
+	/* unmap the DMA buffers */
 	temp64.val32.lower = c->SG[0].Addr.lower;
 	temp64.val32.upper = c->SG[0].Addr.upper;
-	pci_unmap_single(h->pdev, (dma_addr_t) temp64.val, iocommand.buf_size,
-			 PCI_DMA_BIDIRECTIONAL);
+	pci_unmap_single(h->pdev, (dma_addr_t) temp64.val,
+			 iocommand.buf_size, PCI_DMA_BIDIRECTIONAL);
+
 	check_ioctl_unit_attention(h, c);
 
 	/* Copy the error information out */
@@ -1619,19 +1597,28 @@ static int cciss_bigpassthru(ctlr_info_t *h, void __user *argp)
 	}
 	c->cmd_type = CMD_IOCTL_PEND;
 	c->Header.ReplyQueue = 0;
-	c->Header.SGList = sg_used;
-	c->Header.SGTotal = sg_used;
+
+	if (ioc->buf_size > 0) {
+		c->Header.SGList = sg_used;
+		c->Header.SGTotal = sg_used;
+	} else {
+		c->Header.SGList = 0;
+		c->Header.SGTotal = 0;
+	}
 	c->Header.LUN = ioc->LUN_info;
 	c->Header.Tag.lower = c->busaddr;
 
 	c->Request = ioc->Request;
-	for (i = 0; i < sg_used; i++) {
-		temp64.val = pci_map_single(h->pdev, buff[i], buff_size[i],
-				    PCI_DMA_BIDIRECTIONAL);
-		c->SG[i].Addr.lower = temp64.val32.lower;
-		c->SG[i].Addr.upper = temp64.val32.upper;
-		c->SG[i].Len = buff_size[i];
-		c->SG[i].Ext = 0;	/* we are not chaining */
+	if (ioc->buf_size > 0) {
+		int i;
+		for (i = 0; i < sg_used; i++) {
+			temp64.val = pci_map_single(h->pdev, buff[i],
+				    buff_size[i], PCI_DMA_BIDIRECTIONAL);
+			c->SG[i].Addr.lower = temp64.val32.lower;
+			c->SG[i].Addr.upper = temp64.val32.upper;
+			c->SG[i].Len = buff_size[i];
+			c->SG[i].Ext = 0;	/* we are not chaining */
+		}
 	}
 	c->waiting = &wait;
 	enqueue_cmd_and_start_io(h, c);
@@ -1640,9 +1627,8 @@ static int cciss_bigpassthru(ctlr_info_t *h, void __user *argp)
 	for (i = 0; i < sg_used; i++) {
 		temp64.val32.lower = c->SG[i].Addr.lower;
 		temp64.val32.upper = c->SG[i].Addr.upper;
-		pci_unmap_single(h->pdev,
-			(dma_addr_t) temp64.val, buff_size[i],
-			PCI_DMA_BIDIRECTIONAL);
+		pci_unmap_single(h->pdev, (dma_addr_t) temp64.val,
+			buff_size[i], PCI_DMA_BIDIRECTIONAL);
 	}
 	check_ioctl_unit_attention(h, c);
 	/* Copy the error information out */
@@ -1678,7 +1664,7 @@ cleanup1:
 }
 
 static int cciss_ioctl(struct block_device *bdev, fmode_t mode,
-	unsigned int cmd, unsigned long arg)
+       unsigned int cmd, unsigned long arg)
 {
 	struct gendisk *disk = bdev->bd_disk;
 	ctlr_info_t *h = get_host(disk);
@@ -1881,8 +1867,8 @@ static void cciss_get_device_descr(ctlr_info_t *h, int logvol,
  * number cannot be had, for whatever reason, 16 bytes of 0xff
  * are returned instead.
  */
-static void cciss_get_serial_no(ctlr_info_t *h, int logvol,
-				unsigned char *serial_no, int buflen)
+static void cciss_get_uid(ctlr_info_t *h, int logvol,
+				unsigned char *uid, int buflen)
 {
 #define PAGE_83_INQ_BYTES 64
 	int rc;
@@ -1891,16 +1877,16 @@ static void cciss_get_serial_no(ctlr_info_t *h, int logvol,
 
 	if (buflen > 16)
 		buflen = 16;
-	memset(serial_no, 0xff, buflen);
+	memset(uid, 0xff, buflen);
 	buf = kzalloc(PAGE_83_INQ_BYTES, GFP_KERNEL);
 	if (!buf)
 		return;
-	memset(serial_no, 0, buflen);
+	memset(uid, 0, buflen);
 	log_unit_to_scsi3addr(h, scsi3addr, logvol);
 	rc = sendcmd_withirq(h, CISS_INQUIRY, buf,
 		PAGE_83_INQ_BYTES, 0x83, scsi3addr, TYPE_CMD);
 	if (rc == IO_OK)
-		memcpy(serial_no, &buf[8], buflen);
+		memcpy(uid, &buf[8], buflen);
 	kfree(buf);
 	return;
 }
@@ -2008,16 +1994,15 @@ static void cciss_update_drive_info(ctlr_info_t *h, int drv_index,
 
 	cciss_get_device_descr(h, drv_index, drvinfo->vendor,
 				drvinfo->model, drvinfo->rev);
-	cciss_get_serial_no(h, drv_index, drvinfo->serial_no,
-			sizeof(drvinfo->serial_no));
+	cciss_get_uid(h, drv_index, drvinfo->uid, sizeof(drvinfo->uid));
 	/* Save the lunid in case we deregister the disk, below. */
 	memcpy(drvinfo->LunID, h->drv[drv_index]->LunID,
 		sizeof(drvinfo->LunID));
 
 	/* Is it the same disk we already know, and nothing's changed? */
 	if (h->drv[drv_index]->raid_level != -1 &&
-		((memcmp(drvinfo->serial_no,
-				h->drv[drv_index]->serial_no, 16) == 0) &&
+		((memcmp(drvinfo->uid,
+				h->drv[drv_index]->uid, 16) == 0) &&
 		drvinfo->block_size == h->drv[drv_index]->block_size &&
 		drvinfo->nr_blocks == h->drv[drv_index]->nr_blocks &&
 		drvinfo->heads == h->drv[drv_index]->heads &&
@@ -2065,7 +2050,7 @@ static void cciss_update_drive_info(ctlr_info_t *h, int drv_index,
 		h->drv[drv_index]->sectors = drvinfo->sectors;
 		h->drv[drv_index]->cylinders = drvinfo->cylinders;
 		h->drv[drv_index]->raid_level = drvinfo->raid_level;
-		memcpy(h->drv[drv_index]->serial_no, drvinfo->serial_no, 16);
+		memcpy(h->drv[drv_index]->uid, drvinfo->uid, 16);
 		memcpy(h->drv[drv_index]->vendor, drvinfo->vendor,
 			VENDOR_LEN + 1);
 		memcpy(h->drv[drv_index]->model, drvinfo->model, MODEL_LEN + 1);
@@ -2075,6 +2060,7 @@ static void cciss_update_drive_info(ctlr_info_t *h, int drv_index,
 	++h->num_luns;
 	disk = h->gendisk[drv_index];
 	set_capacity(disk, h->drv[drv_index]->nr_blocks);
+	cciss_sysfs_stat_inquiry(h, drv_index, h->drv[drv_index]);
 
 	/* If it's not disk 0 (drv_index != 0)
 	 * or if it was disk 0, but there was previously
@@ -2235,7 +2221,7 @@ static void cciss_add_controller_node(ctlr_info_t *h)
 	h->drv[drv_index]->sectors = 0;
 	h->drv[drv_index]->cylinders = 0;
 	h->drv[drv_index]->raid_level = -1;
-	memset(h->drv[drv_index]->serial_no, 0, 16);
+	memset(h->drv[drv_index]->uid, 0, 16);
 	disk = h->gendisk[drv_index];
 	if (cciss_add_disk(h, disk, drv_index) == 0)
 		return;
@@ -2323,7 +2309,7 @@ static int rebuild_lun_table(ctlr_info_t *h, int first_time,
 		for (j = 0; j < num_luns; j++) {
 			memcpy(lunid, &ld_buff->LUN[j][0], sizeof(lunid));
 			if (memcmp(h->drv[i]->LunID, lunid,
-				sizeof(lunid)) == 0) {
+					sizeof(lunid)) == 0) {
 				drv_found = 1;
 				break;
 			}
@@ -2397,7 +2383,7 @@ static void cciss_clear_drive_info(drive_info_struct *drive_info)
 	drive_info->sectors = 0;
 	drive_info->cylinders = 0;
 	drive_info->raid_level = -1;
-	memset(drive_info->serial_no, 0, sizeof(drive_info->serial_no));
+	memset(drive_info->uid, 0, sizeof(drive_info->uid));
 	memset(drive_info->model, 0, sizeof(drive_info->model));
 	memset(drive_info->rev, 0, sizeof(drive_info->rev));
 	memset(drive_info->vendor, 0, sizeof(drive_info->vendor));
@@ -2492,7 +2478,7 @@ static int deregister_disk(ctlr_info_t *h, int drv_index,
 
 	/* if it was the last disk, find the new hightest lun */
 	if (clear_all && recalculate_highest_lun) {
-		int newhighest = -1;
+		int i, newhighest = -1;
 		for (i = 0; i <= h->highest_lun; i++) {
 			/* if the disk has size > 0, it is available */
 			if (h->drv[i] && h->drv[i]->heads)
@@ -2929,7 +2915,7 @@ static int cciss_revalidate(struct gendisk *disk)
 	InquiryData_struct *inq_buff = NULL;
 
 	for (logvol = 0; logvol <= h->highest_lun; logvol++) {
-		if (!h->drv[logvol])
+		if (!h->drv[logvol]) /* h->drv[] may contain holes */
 			continue;
 		if (memcmp(h->drv[logvol]->LunID, drv->LunID,
 			sizeof(drv->LunID)) == 0) {
@@ -3177,8 +3163,7 @@ static inline void complete_command(ctlr_info_t *h, CommandList_struct *cmd,
 				DID_PASSTHROUGH : DID_ERROR);
 		break;
 	case CMD_UNSOLICITED_ABORT:
-		dev_warn(&h->pdev->dev, "cciss%d: unsolicited "
-		       "abort %p\n", h->ctlr, cmd);
+		dev_warn(&h->pdev->dev, "unsolicited abort %p\n", cmd);
 		if (cmd->retry_count < MAX_CMD_RETRIES) {
 			retry_cmd = 1;
 			dev_warn(&h->pdev->dev, "retrying %p\n", cmd);
@@ -3202,7 +3187,7 @@ static inline void complete_command(ctlr_info_t *h, CommandList_struct *cmd,
 		dev_warn(&h->pdev->dev, "cmd %p unabortable\n", cmd);
 		rq->errors = make_status_bytes(SAM_STAT_GOOD,
 			cmd->err_info->CommandStatus, DRIVER_OK,
-			cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC ?
+			(cmd->rq->cmd_type == REQ_TYPE_BLOCK_PC) ?
 				DID_PASSTHROUGH : DID_ERROR);
 		break;
 	default:
@@ -3275,6 +3260,12 @@ static void do_cciss_request(struct request_queue *q)
 	int sg_index = 0;
 	int chained = 0;
 
+	/* We call start_io here in case there is a command waiting on the
+	 * queue that has not been sent.
+	 */
+	if (blk_queue_plugged(q))
+		goto startio;
+
       queue:
 	creq = blk_peek_request(q);
 	if (!creq)
@@ -3614,127 +3605,6 @@ static irqreturn_t do_cciss_msix_intr(int irq, void *dev_id)
 	return IRQ_HANDLED;
 }
 
-/**
- * add_to_scan_list() - add controller to rescan queue
- * @h:		      Pointer to the controller.
- *
- * Adds the controller to the rescan queue if not already on the queue.
- *
- * returns 1 if added to the queue, 0 if skipped (could be on the
- * queue already, or the controller could be initializing or shutting
- * down).
- **/
-static int add_to_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h;
-	int found = 0;
-	int ret = 0;
-
-	if (h->busy_initializing)
-		return 0;
-
-	if (!mutex_trylock(&h->busy_shutting_down))
-		return 0;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry(test_h, &scan_q, scan_list) {
-		if (test_h == h) {
-			found = 1;
-			break;
-		}
-	}
-	if (!found && !h->busy_scanning) {
-		INIT_COMPLETION(h->scan_wait);
-		list_add_tail(&h->scan_list, &scan_q);
-		ret = 1;
-	}
-	mutex_unlock(&scan_mutex);
-	mutex_unlock(&h->busy_shutting_down);
-
-	return ret;
-}
-
-/**
- * remove_from_scan_list() - remove controller from rescan queue
- * @h:			   Pointer to the controller.
- *
- * Removes the controller from the rescan queue if present. Blocks if
- * the controller is currently conducting a rescan.  The controller
- * can be in one of three states:
- * 1. Doesn't need a scan
- * 2. On the scan list, but not scanning yet (we remove it)
- * 3. Busy scanning (and not on the list). In this case we want to wait for
- *    the scan to complete to make sure the scanning thread for this
- *    controller is completely idle.
- **/
-static void remove_from_scan_list(struct ctlr_info *h)
-{
-	struct ctlr_info *test_h, *tmp_h;
-
-	mutex_lock(&scan_mutex);
-	list_for_each_entry_safe(test_h, tmp_h, &scan_q, scan_list) {
-		if (test_h == h) { /* state 2. */
-			list_del(&h->scan_list);
-			complete_all(&h->scan_wait);
-			mutex_unlock(&scan_mutex);
-			return;
-		}
-	}
-	if (h->busy_scanning) { /* state 3. */
-		mutex_unlock(&scan_mutex);
-		wait_for_completion(&h->scan_wait);
-	} else { /* state 1, nothing to do. */
-		mutex_unlock(&scan_mutex);
-	}
-}
-
-/**
- * scan_thread() - kernel thread used to rescan controllers
- * @data:	 Ignored.
- *
- * A kernel thread used scan for drive topology changes on
- * controllers. The thread processes only one controller at a time
- * using a queue.  Controllers are added to the queue using
- * add_to_scan_list() and removed from the queue either after done
- * processing or using remove_from_scan_list().
- *
- * returns 0.
- **/
-static int scan_thread(void *data)
-{
-	struct ctlr_info *h;
-
-	while (1) {
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule();
-		if (kthread_should_stop())
-			break;
-
-		while (1) {
-			mutex_lock(&scan_mutex);
-			if (list_empty(&scan_q)) {
-				mutex_unlock(&scan_mutex);
-				break;
-			}
-
-			h = list_entry(scan_q.next,
-				       struct ctlr_info,
-				       scan_list);
-			list_del(&h->scan_list);
-			h->busy_scanning = 1;
-			mutex_unlock(&scan_mutex);
-
-			rebuild_lun_table(h, 0, 0);
-			complete_all(&h->scan_wait);
-			mutex_lock(&scan_mutex);
-			h->busy_scanning = 0;
-			mutex_unlock(&scan_mutex);
-		}
-	}
-
-	return 0;
-}
-
 static int check_for_unit_attention(ctlr_info_t *h, CommandList_struct *c)
 {
 	if (c->err_info->SenseInfo[2] != UNIT_ATTENTION)
@@ -4095,9 +3965,10 @@ static int __devinit cciss_lookup_board_id(struct pci_dev *pdev, u32 *board_id)
 	*board_id = ((subsystem_device_id << 16) & 0xffff0000) |
 			subsystem_vendor_id;
 
-	for (i = 0; i < ARRAY_SIZE(products); i++)
+	for (i = 0; i < ARRAY_SIZE(products); i++) {
 		if (*board_id == products[i].board_id)
 			return i;
+	}
 	dev_warn(&pdev->dev, "unrecognized board ID: 0x%08x, ignoring.\n",
 		*board_id);
 	return -ENODEV;
@@ -4185,7 +4056,7 @@ static int __devinit cciss_find_cfgtables(ctlr_info_t *h)
 	if (rc)
 		return rc;
 	h->cfgtable = remap_pci_mem(pci_resource_start(h->pdev,
-		cfg_base_addr_index) + cfg_offset, sizeof(h->cfgtable));
+		cfg_base_addr_index) + cfg_offset, sizeof(*h->cfgtable));
 	if (!h->cfgtable)
 		return -ENOMEM;
 	rc = write_driver_ver_to_cfgtable(h->cfgtable);
@@ -4690,6 +4561,7 @@ static __devinit int cciss_kdump_hard_reset_controller(struct pci_dev *pdev)
 	rc = cciss_controller_hard_reset(pdev, vaddr, use_doorbell);
 	if (rc)
 		goto unmap_cfgtable;
+
 	pci_restore_state(pdev);
 	rc = pci_enable_device(pdev);
 	if (rc) {
@@ -4897,10 +4769,6 @@ static void cciss_undo_allocations_after_kdump_soft_reset(ctlr_info_t *h)
 	cciss_free_sg_chain_blocks(h->cmd_sg_list, h->nr_cmds);
 	cciss_free_scatterlists(h);
 	cciss_free_cmd_pool(h);
-	kfree(h->blockFetchTable);
-	if (h->reply_pool)
-		pci_free_consistent(h->pdev, h->max_commands * sizeof(__u64),
-				h->reply_pool, h->reply_pool_dhandle);
 	if (h->transtable)
 		iounmap(h->transtable);
 	if (h->cfgtable)
@@ -4957,9 +4825,6 @@ reinit_after_soft_reset:
 	INIT_LIST_HEAD(&h->reqQ);
 	mutex_init(&h->busy_shutting_down);
 
-	if (cciss_pci_init(h) != 0)
-		goto clean_no_release_regions;
-
 	sprintf(h->devname, "cciss%d", i);
 	h->ctlr = i;
 
@@ -4968,7 +4833,8 @@ reinit_after_soft_reset:
 	if (cciss_tape_cmds > 16)
 		cciss_tape_cmds = 16;
 
-	init_completion(&h->scan_wait);
+	if (cciss_pci_init(h) != 0)
+		goto clean_no_release_regions;
 
 	if (cciss_create_hba_sysfs_entry(h))
 		goto clean0;
@@ -5193,8 +5059,6 @@ static void __devexit cciss_remove_one(struct pci_dev *pdev)
 	}
 
 	mutex_lock(&h->busy_shutting_down);
-
-	remove_from_scan_list(h);
 	remove_proc_entry(h->devname, proc_cciss);
 	unregister_blkdev(h->major, h->devname);
 
@@ -5279,25 +5143,14 @@ static int __init cciss_init(void)
 	if (err)
 		return err;
 
-	/* Start the scan thread */
-	cciss_scan_thread = kthread_run(scan_thread, NULL, "cciss_scan");
-	if (IS_ERR(cciss_scan_thread)) {
-		err = PTR_ERR(cciss_scan_thread);
-		goto err_bus_unregister;
-	}
-
 	/* Register for our PCI devices */
 	err = pci_register_driver(&cciss_pci_driver);
 	if (err)
-		goto err_thread_stop;
-
+		goto err_bus_unregister;
 	return err;
 
-err_thread_stop:
-	kthread_stop(cciss_scan_thread);
 err_bus_unregister:
 	bus_unregister(&cciss_bus_type);
-
 	return err;
 }
 
@@ -5314,11 +5167,51 @@ static void __exit cciss_cleanup(void)
 			cciss_remove_one(hba[i]->pdev);
 		}
 	}
-	kthread_stop(cciss_scan_thread);
 	if (proc_cciss)
 		remove_proc_entry("driver/cciss", NULL);
 	bus_unregister(&cciss_bus_type);
 }
 
+static void cciss_sysfs_stat_inquiry(ctlr_info_t *h, int logvol,
+			drive_info_struct *drv)
+{
+	int return_code;
+	InquiryData_struct *inq_buff;
+	unsigned char scsi3addr[8];
+
+	/* If there are no heads then this is the controller disk and
+	 * not a valid logical drive so don't query it.
+	 */
+	if (!drv->heads)
+		return;
+
+	inq_buff = kzalloc(sizeof(InquiryData_struct), GFP_KERNEL);
+	if (!inq_buff) {
+		dev_err(&h->pdev->dev, "out of memory\n");
+		goto err;
+	}
+	log_unit_to_scsi3addr(h, scsi3addr, logvol);
+	return_code = sendcmd_withirq(h, CISS_INQUIRY, inq_buff, sizeof(*inq_buff), 0,
+			scsi3addr, TYPE_CMD);
+	if (return_code == IO_OK) {
+		memcpy(drv->vendor, &inq_buff->data_byte[8], 8);
+		drv->vendor[8]='\0';
+		memcpy(drv->model, &inq_buff->data_byte[16], 16);
+		drv->model[16] = '\0';
+		memcpy(drv->rev, &inq_buff->data_byte[32], 4);
+		drv->rev[4] = '\0';
+	} else { /* Get geometry failed */
+		dev_warn(&h->pdev->dev, "inquiry for VPD page 0 failed\n");
+	}
+	kfree(inq_buff);
+	cciss_get_uid(h, logvol, drv->uid, sizeof(drv->uid));
+
+err:
+	drv->vendor[8] = '\0';
+	drv->model[16] = '\0';
+	drv->rev[4] = '\0';
+
+}
+
 module_init(cciss_init);
 module_exit(cciss_cleanup);
diff --git a/drivers/block/cciss.h b/drivers/block/cciss.h
index 16b4d58..7d02647 100644
--- a/drivers/block/cciss.h
+++ b/drivers/block/cciss.h
@@ -31,13 +31,14 @@ struct access_method {
 typedef struct _drive_info_struct
 {
 	unsigned char LunID[8];
-	int 	usage_count;
+#define CCISS_HBA_LUNID "\0\0\0\0\0\0\0\0"
+	int	usage_count;
 	struct request_queue *queue;
 	sector_t nr_blocks;
 	int	block_size;
-	int 	heads;
+	int	heads;
 	int	sectors;
-	int 	cylinders;
+	int	cylinders;
 	int	raid_level; /* set to -1 to indicate that
 			     * the drive is not in use/configured
 			     */
@@ -45,16 +46,21 @@ typedef struct _drive_info_struct
 				   * to prevent it from being opened or it's
 				   * queue from being started.
 				   */
-	struct	device dev;
-	__u8 serial_no[16]; /* from inquiry page 0x83,
-			     * not necc. null terminated.
-			     */
+	struct device dev;
+	__u8 uid[16];	    /* from inquiry page 0x83,
+			    /* not necc. null terminated.
+			    */
 	char vendor[VENDOR_LEN + 1]; /* SCSI vendor string */
 	char model[MODEL_LEN + 1];   /* SCSI model string */
 	char rev[REV_LEN + 1];       /* SCSI revision string */
 	char device_initialized;     /* indicates whether dev is initialized */
 } drive_info_struct;
 
+struct Cmd_sg_list {
+	dma_addr_t		sg_chain_dma;
+	int			chain_block_size;
+};
+
 struct ctlr_info
 {
 	int	ctlr;
@@ -65,15 +71,15 @@ struct ctlr_info
 	__u32	board_id;
 	void __iomem *vaddr;
 	unsigned long paddr;
-	int 	nr_cmds; /* Number of commands allowed on this controller */
+	int	nr_cmds; /* Number of commands allowed on this controller */
 	CfgTable_struct __iomem *cfgtable;
 	int	interrupts_enabled;
 	int	major;
-	int 	max_commands;
+	int	max_commands;
 	int	commands_outstanding;
-	int 	max_outstanding; /* Debug */ 
+	int	max_outstanding; /* Debug */
 	int	num_luns;
-	int 	highest_lun;
+	int	highest_lun;
 	int	usage_count;  /* number of opens all all minor devices */
 	/* Need space for temp sg list
 	 * number of scatter/gathers supported
@@ -92,7 +98,7 @@ struct ctlr_info
 	unsigned int intr[4];
 	unsigned int msix_vector;
 	unsigned int msi_vector;
-	int 	cciss_max_sectors;
+	int	cciss_max_sectors;
 	BYTE	cciss_read;
 	BYTE	cciss_write;
 	BYTE	cciss_read_capacity;
@@ -102,7 +108,7 @@ struct ctlr_info
 
 	struct access_method access;
 
-	/* queue and queue Info */ 
+	/* queue and queue Info */
 	struct list_head reqQ;
 	struct list_head cmpQ;
 	unsigned int Qdepth;
@@ -111,16 +117,15 @@ struct ctlr_info
 	spinlock_t lock;
 
 	/* pointers to command and error info pool */
-	CommandList_struct 	*cmd_pool;
-	dma_addr_t		cmd_pool_dhandle; 
-	ErrorInfo_struct 	*errinfo_pool;
-	dma_addr_t		errinfo_pool_dhandle; 
-        unsigned long  		*cmd_pool_bits;
+	CommandList_struct	*cmd_pool;
+	dma_addr_t		cmd_pool_dhandle;
+	ErrorInfo_struct	*errinfo_pool;
+	dma_addr_t		errinfo_pool_dhandle;
+	unsigned long		*cmd_pool_bits;
 	int			nr_allocs;
-	int			nr_frees; 
+	int			nr_frees;
 	int			busy_configuring;
 	int			busy_initializing;
-	int			busy_scanning;
 	struct mutex		busy_shutting_down;
 
 	/* This element holds the zero based queue number of the last
@@ -134,8 +139,6 @@ struct ctlr_info
 	struct cciss_scsi_adapter_data_t *scsi_ctlr;
 #endif
 	unsigned char alive;
-	struct list_head scan_list;
-	struct completion scan_wait;
 	struct device dev;
 	/*
 	 * Performant mode tables.
@@ -174,21 +177,21 @@ struct ctlr_info
 #define SA5B_INTR_OFF		0x04
 #define SA5_INTR_PENDING	0x08
 #define SA5B_INTR_PENDING	0x04
-#define FIFO_EMPTY		0xffffffff	
+#define FIFO_EMPTY		0xffffffff
 #define CCISS_FIRMWARE_READY	0xffff0000 /* value in scratchpad register */
 /* Perf. mode flags */
 #define SA5_PERF_INTR_PENDING	0x04
 #define SA5_PERF_INTR_OFF	0x05
 #define SA5_OUTDB_STATUS_PERF_BIT	0x01
 #define SA5_OUTDB_CLEAR_PERF_BIT	0x01
-#define SA5_OUTDB_CLEAR         0xA0
-#define SA5_OUTDB_CLEAR_PERF_BIT        0x01
-#define SA5_OUTDB_STATUS        0x9C
+#define SA5_OUTDB_CLEAR			0xA0
+#define SA5_OUTDB_CLEAR_PERF_BIT	0x01
+#define SA5_OUTDB_STATUS		0x9C
 
 
 #define  CISS_ERROR_BIT		0x02
 
-#define CCISS_INTR_ON 	1 
+#define CCISS_INTR_ON	1
 #define CCISS_INTR_OFF	0
 
 
@@ -209,34 +212,34 @@ struct ctlr_info
 	((CCISS_BOARD_NOT_READY_WAIT_SECS * 1000) / \
 		CCISS_BOARD_READY_POLL_INTERVAL_MSECS)
 #define CCISS_POST_RESET_PAUSE_MSECS (3000)
-#define CCISS_POST_RESET_NOOP_INTERVAL_MSECS (4000)
+#define CCISS_POST_RESET_NOOP_INTERVAL_MSECS (1000)
 #define CCISS_POST_RESET_NOOP_RETRIES (12)
 #define CCISS_POST_RESET_NOOP_TIMEOUT_MSECS (10000)
 
-/* 
-	Send the command to the hardware 
+/*
+	Send the command to the hardware
 */
-static void SA5_submit_command( ctlr_info_t *h, CommandList_struct *c) 
+static void SA5_submit_command( ctlr_info_t *h, CommandList_struct *c)
 {
 #ifdef CCISS_DEBUG
 	printk(KERN_WARNING "cciss%d: Sending %08x - down to controller\n",
 			h->ctlr, c->busaddr);
 #endif /* CCISS_DEBUG */
-         writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
-	readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
-	 h->commands_outstanding++;
-	 if ( h->commands_outstanding > h->max_outstanding)
+	writel(c->busaddr, h->vaddr + SA5_REQUEST_PORT_OFFSET);
+	(void) readl(h->vaddr + SA5_SCRATCHPAD_OFFSET);
+	h->commands_outstanding++;
+	if ( h->commands_outstanding > h->max_outstanding)
 		h->max_outstanding = h->commands_outstanding;
 }
 
-/*  
- *  This card is the opposite of the other cards.  
- *   0 turns interrupts on... 
- *   0x08 turns them off... 
+/*
+ *  This card is the opposite of the other cards.
+ *   0 turns interrupts on...
+ *   0x08 turns them off...
  */
 static void SA5_intr_mask(ctlr_info_t *h, unsigned long val)
 {
-	if (val) 
+	if (val)
 	{ /* Turn interrupts on */
 		h->interrupts_enabled = 1;
 		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
@@ -244,7 +247,7 @@ static void SA5_intr_mask(ctlr_info_t *h, unsigned long val)
 	} else /* Turn them off */
 	{
 		h->interrupts_enabled = 0;
-        	writel( SA5_INTR_OFF, 
+		writel( SA5_INTR_OFF,
 			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 	}
@@ -256,18 +259,16 @@ static void SA5_intr_mask(ctlr_info_t *h, unsigned long val)
  */
 static void SA5B_intr_mask(ctlr_info_t *h, unsigned long val)
 {
-        if (val)
-        { /* Turn interrupts on */
+	if (val) { /* Turn interrupts on */
 		h->interrupts_enabled = 1;
-                writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		writel(0, h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
-        } else /* Turn them off */
-        {
+	} else { /* Turn them off */
 		h->interrupts_enabled = 0;
-                writel( SA5B_INTR_OFF,
-                        h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
+		writel( SA5B_INTR_OFF,
+			h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
 		(void) readl(h->vaddr + SA5_REPLY_INTR_MASK_OFFSET);
-        }
+	}
 }
 
 /* Performant mode intr_mask */
@@ -286,39 +287,39 @@ static void SA5_performant_intr_mask(ctlr_info_t *h, unsigned long val)
 }
 
 /*
- *  Returns true if fifo is full.  
- * 
- */ 
+ *  Returns true if fifo is full.
+ *
+ */
 static unsigned long SA5_fifo_full(ctlr_info_t *h)
 {
 	if( h->commands_outstanding >= h->max_commands)
 		return(1);
-	else 
+	else
 		return(0);
 
 }
-/* 
- *   returns value read from hardware. 
- *     returns FIFO_EMPTY if there is nothing to read 
- */ 
+/*
+ *   returns value read from hardware.
+ *     returns FIFO_EMPTY if there is nothing to read
+ */
 static unsigned long SA5_completed(ctlr_info_t *h)
 {
-	unsigned long register_value 
+	unsigned long register_value
 		= readl(h->vaddr + SA5_REPLY_PORT_OFFSET);
 	if(register_value != FIFO_EMPTY)
 	{
 		h->commands_outstanding--;
 #ifdef CCISS_DEBUG
 		printk("cciss:  Read %lx back from board\n", register_value);
-#endif /* CCISS_DEBUG */ 
-	} 
+#endif /* CCISS_DEBUG */
+	}
 #ifdef CCISS_DEBUG
 	else
 	{
 		printk("cciss:  FIFO Empty read\n");
 	}
-#endif 
-	return ( register_value); 
+#endif
+	return ( register_value);
 
 }
 
@@ -356,17 +357,17 @@ static unsigned long SA5_performant_completed(ctlr_info_t *h)
 	return register_value;
 }
 /*
- *	Returns true if an interrupt is pending.. 
+ *	Returns true if an interrupt is pending..
  */
 static bool SA5_intr_pending(ctlr_info_t *h)
 {
-	unsigned long register_value  = 
+	unsigned long register_value  =
 		readl(h->vaddr + SA5_INTR_STATUS);
 #ifdef CCISS_DEBUG
 	printk("cciss: intr_pending %lx\n", register_value);
 #endif  /* CCISS_DEBUG */
-	if( register_value &  SA5_INTR_PENDING) 
-		return  1;	
+	if( register_value &  SA5_INTR_PENDING)
+		return  1;
 	return 0 ;
 }
 
@@ -375,14 +376,14 @@ static bool SA5_intr_pending(ctlr_info_t *h)
  */
 static bool SA5B_intr_pending(ctlr_info_t *h)
 {
-        unsigned long register_value  =
-                readl(h->vaddr + SA5_INTR_STATUS);
+	unsigned long register_value  =
+		readl(h->vaddr + SA5_INTR_STATUS);
 #ifdef CCISS_DEBUG
-        printk("cciss: intr_pending %lx\n", register_value);
+	printk("cciss: intr_pending %lx\n", register_value);
 #endif  /* CCISS_DEBUG */
-        if( register_value &  SA5B_INTR_PENDING)
-                return  1;
-        return 0 ;
+	if( register_value &  SA5B_INTR_PENDING)
+		return  1;
+	return 0 ;
 }
 
 static bool SA5_performant_intr_pending(ctlr_info_t *h)
@@ -409,11 +410,11 @@ static struct access_method SA5_access = {
 };
 
 static struct access_method SA5B_access = {
-        SA5_submit_command,
-        SA5B_intr_mask,
-        SA5_fifo_full,
-        SA5B_intr_pending,
-        SA5_completed,
+	SA5_submit_command,
+	SA5B_intr_mask,
+	SA5_fifo_full,
+	SA5B_intr_pending,
+	SA5_completed,
 };
 
 static struct access_method SA5_performant_access = {
diff --git a/drivers/block/cciss_cmd.h b/drivers/block/cciss_cmd.h
index d9be6b4..bede709 100644
--- a/drivers/block/cciss_cmd.h
+++ b/drivers/block/cciss_cmd.h
@@ -76,7 +76,7 @@ typedef union _u64bit
 } u64bit;
 
 /* Type defs used in the following structs */
-#define QWORD vals32 
+#define QWORD vals32
 
 /* STRUCTURES */
 #define CISS_MAX_PHYS_LUN	1024
@@ -101,7 +101,7 @@ typedef struct _ReportLUNdata_struct
   BYTE LUN[CISS_MAX_LUN][8];
 } ReportLunData_struct;
 
-#define CCISS_READ_CAPACITY 0x25 /* Read Capacity */ 
+#define CCISS_READ_CAPACITY 0x25 /* Read Capacity */
 typedef struct _ReadCapdata_struct
 {
   BYTE total_size[4];	/* Total size in blocks */
@@ -199,11 +199,11 @@ typedef struct _CommandList_struct {
   RequestBlock_struct      Request;
   ErrDescriptor_struct     ErrDesc;
   SGDescriptor_struct      SG[MAXSGENTRIES];
-	/* information associated with the command */ 
+	/* information associated with the command */
   __u32			   busaddr; /* physical address of this record */
-  ErrorInfo_struct * 	   err_info; /* pointer to the allocated mem */ 
+  ErrorInfo_struct *	   err_info; /* pointer to the allocated mem */
   int			   ctlr;
-  int			   cmd_type; 
+  int			   cmd_type;
   long			   cmdindex;
   struct list_head list;
   struct request *	   rq;
@@ -245,7 +245,7 @@ typedef struct _CfgTable_struct {
   u32		   misc_fw_support; /* offset 0x78 */
 #define MISC_FW_DOORBELL_RESET (0x02)
 #define MISC_FW_DOORBELL_RESET2 (0x10)
-	u8	   driver_version[32];
+  u8		   driver_version[32];
 } CfgTable_struct;
 
 struct TransTable_struct {
@@ -265,5 +265,5 @@ struct TransTable_struct {
   u32 RepQAddr0High32;
 };
 
-#pragma pack()	 
+#pragma pack()
 #endif /* CCISS_CMD_H */
diff --git a/drivers/block/cciss_scsi.c b/drivers/block/cciss_scsi.c
index 6961002..c8b8fd1 100644
--- a/drivers/block/cciss_scsi.c
+++ b/drivers/block/cciss_scsi.c
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers, SCSI Tape module.
- *    (C) Copyright 2001, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2001, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -17,15 +17,15 @@
  *    02111-1307, USA.
  *
  *    Questions/Comments/Bugfixes to iss_storagedev@hp.com
- *    
+ *
  *    Author: Stephen M. Cameron
  */
 #ifdef CONFIG_CISS_SCSI_TAPE
 
-/* Here we have code to present the driver as a scsi driver 
-   as it is simultaneously presented as a block driver.  The 
+/* Here we have code to present the driver as a scsi driver
+   as it is simultaneously presented as a block driver.  The
    reason for doing this is to allow access to SCSI tape drives
-   through the array controller.  Note in particular, neither 
+   through the array controller.  Note in particular, neither
    physical nor logical disks are presented through the scsi layer. */
 
 #include <linux/timer.h>
@@ -37,7 +37,7 @@
 
 #include <scsi/scsi_cmnd.h>
 #include <scsi/scsi_device.h>
-#include <scsi/scsi_host.h> 
+#include <scsi/scsi_host.h>
 
 #include "cciss_scsi.h"
 
@@ -102,12 +102,9 @@ struct cciss_scsi_cmd_stack_elem_t {
 	ErrorInfo_struct Err;
 	__u32 busaddr;
 	int cmdindex;
-	u8 pad[IS_32_BIT * SCSI_PAD_32 + IS_64_BIT * SCSI_PAD_64];
+	unsigned char pad[IS_32_BIT * SCSI_PAD_32 + IS_64_BIT * SCSI_PAD_64];
 };
 
-#pragma pack()
-
-#pragma pack(1)
 struct cciss_scsi_cmd_stack_t {
 	struct cciss_scsi_cmd_stack_elem_t *pool;
 	struct cciss_scsi_cmd_stack_elem_t **elem;
@@ -122,7 +119,7 @@ struct cciss_scsi_adapter_data_t {
 	struct cciss_scsi_cmd_stack_t cmd_stack;
 	SGDescriptor_struct **cmd_sg_list;
 	int registered;
-	spinlock_t lock; // to protect ccissscsi[ctlr]; 
+	spinlock_t lock; // to protect ccissscsi[ctlr];
 };
 
 #define CPQ_TAPE_LOCK(h, flags) spin_lock_irqsave( \
@@ -145,36 +142,36 @@ scsi_cmd_alloc(ctlr_info_t *h)
 	u64bit temp64;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
-	if (stk->top < 0) 
+	if (stk->top < 0)
 		return NULL;
-	c = stk->elem[stk->top]; 	
+	c = stk->elem[stk->top];
 	/* memset(c, 0, sizeof(*c)); */
 	memset(&c->cmd, 0, sizeof(c->cmd));
 	memset(&c->Err, 0, sizeof(c->Err));
 	/* set physical addr of cmd and addr of scsi parameters */
-	c->cmd.busaddr = c->busaddr; 
+	c->cmd.busaddr = c->busaddr;
 	c->cmd.cmdindex = c->cmdindex;
-	/* (__u32) (stk->cmd_pool_handle + 
+	/* (__u32) (stk->cmd_pool_handle +
 		(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk->top)); */
 
 	temp64.val = (__u64) (c->busaddr + sizeof(CommandList_struct));
-	/* (__u64) (stk->cmd_pool_handle + 
+	/* (__u64) (stk->cmd_pool_handle +
 		(sizeof(struct cciss_scsi_cmd_stack_elem_t)*stk->top) +
 		 sizeof(CommandList_struct)); */
 	stk->top--;
 	c->cmd.ErrDesc.Addr.lower = temp64.val32.lower;
 	c->cmd.ErrDesc.Addr.upper = temp64.val32.upper;
 	c->cmd.ErrDesc.Len = sizeof(ErrorInfo_struct);
-	
+
 	c->cmd.ctlr = h->ctlr;
 	c->cmd.err_info = &c->Err;
 
 	return (CommandList_struct *) c;
 }
 
-static void 
+static void
 scsi_cmd_free(ctlr_info_t *h, CommandList_struct *c)
 {
 	/* assume only one process in here at a time, locking done by caller. */
@@ -185,7 +182,7 @@ scsi_cmd_free(ctlr_info_t *h, CommandList_struct *c)
 	struct cciss_scsi_cmd_stack_t *stk;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 	stk->top++;
 	if (stk->top >= stk->nelems) {
 		dev_err(&h->pdev->dev,
@@ -225,16 +222,16 @@ scsi_cmd_stack_setup(ctlr_info_t *h, struct cciss_scsi_adapter_data_t *sa)
 	stk->elem = kmalloc(sizeof(stk->elem[0]) * stk->nelems, GFP_KERNEL);
 	if (!stk->elem) {
 		pci_free_consistent(h->pdev, size, stk->pool,
-		stk->cmd_pool_handle);
+			stk->cmd_pool_handle);
 		return -1;
 	}
 	for (i = 0; i < stk->nelems; i++) {
 		stk->elem[i] = &stk->pool[i];
-		stk->elem[i]->busaddr = (__u32) (stk->cmd_pool_handle + 
+		stk->elem[i]->busaddr = (__u32) (stk->cmd_pool_handle +
 			(sizeof(struct cciss_scsi_cmd_stack_elem_t) * i));
 		stk->elem[i]->cmdindex = i;
 	}
-	stk->top = stk->nelems-1;
+	stk->top = stk->nelems - 1;
 	return 0;
 }
 
@@ -246,8 +243,8 @@ scsi_cmd_stack_free(ctlr_info_t *h)
 	size_t size;
 
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
-	if (stk->top != stk->nelems-1) {
+	stk = &sa->cmd_stack;
+	if (stk->top != stk->nelems - 1) {
 		dev_warn(&h->pdev->dev,
 			"bug: %d scsi commands are still outstanding.\n",
 			stk->nelems - stk->top);
@@ -305,7 +302,7 @@ print_cmd(CommandList_struct *cp)
 	printk("queue:%d\n", cp->Header.ReplyQueue);
 	printk("sglist:%d\n", cp->Header.SGList);
 	printk("sgtot:%d\n", cp->Header.SGTotal);
-	printk("Tag:0x%08x/0x%08x\n", cp->Header.Tag.upper, 
+	printk("Tag:0x%08x/0x%08x\n", cp->Header.Tag.upper,
 			cp->Header.Tag.lower);
 	printk("LUN:0x%02x%02x%02x%02x%02x%02x%02x%02x\n",
 		cp->Header.LUN.LunAddrBytes[0],
@@ -331,8 +328,8 @@ print_cmd(CommandList_struct *cp)
 		cp->Request.CDB[10], cp->Request.CDB[11],
 		cp->Request.CDB[12], cp->Request.CDB[13],
 		cp->Request.CDB[14], cp->Request.CDB[15]),
-	printk("edesc.Addr: 0x%08x/0%08x, Len  = %d\n", 
-		cp->ErrDesc.Addr.upper, cp->ErrDesc.Addr.lower, 
+	printk("edesc.Addr: 0x%08x/0%08x, Len  = %d\n",
+		cp->ErrDesc.Addr.upper, cp->ErrDesc.Addr.lower,
 			cp->ErrDesc.Len);
 	printk("sgs..........Errorinfo:\n");
 	printk("scsistatus:%d\n", cp->err_info->ScsiStatus);
@@ -342,12 +339,11 @@ print_cmd(CommandList_struct *cp)
 	printk("offense size:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_size);
 	printk("offense byte:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_num);
 	printk("offense value:%d\n", cp->err_info->MoreErrInfo.Invalid_Cmd.offense_value);
-			
 }
 
 #endif
 
-static int 
+static int
 find_bus_target_lun(ctlr_info_t *h, int *bus, int *target, int *lun)
 {
 	/* finds an unused bus, target, lun for a new device */
@@ -357,24 +353,24 @@ find_bus_target_lun(ctlr_info_t *h, int *bus, int *target, int *lun)
 
 	memset(&target_taken[0], 0, CCISS_MAX_SCSI_DEVS_PER_HBA);
 
-	target_taken[SELF_SCSI_ID] = 1;	
+	target_taken[SELF_SCSI_ID] = 1;
 	for (i = 0; i < ccissscsi[h->ctlr].ndevices; i++)
 		target_taken[ccissscsi[h->ctlr].dev[i].target] = 1;
-	
+
 	for (i = 0; i < CCISS_MAX_SCSI_DEVS_PER_HBA; i++) {
 		if (!target_taken[i]) {
 			*bus = 0; *target=i; *lun = 0; found=1;
 			break;
 		}
 	}
-	return (!found);	
+	return (!found);
 }
 struct scsi2map {
 	char scsi3addr[8];
 	int bus, target, lun;
 };
 
-static int 
+static int
 cciss_scsi_add_entry(ctlr_info_t *h, int hostno,
 		struct cciss_scsi_dev_t *device,
 		struct scsi2map *added, int *nadded)
@@ -439,8 +435,8 @@ cciss_scsi_add_entry(ctlr_info_t *h, int hostno,
 
 	ccissscsi[h->ctlr].ndevices++;
 
-	/* initially, (before registering with scsi layer) we don't 
-	   know our hostno and we don't want to print anything first 
+	/* initially, (before registering with scsi layer) we don't
+	   know our hostno and we don't want to print anything first
 	   time anyway (the scsi layer's inquiries will show that info) */
 	if (hostno != -1)
 		dev_info(&h->pdev->dev, "%s device c%db%dt%dl%d added.\n",
@@ -525,7 +521,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h, int hostno,
 	/* sd contains scsi3 addresses and devtypes, but
 	   bus target and lun are not filled in.  This funciton
 	   takes what's in sd to be the current and adjusts
-	   ccissscsi[] to be in line with what's in sd. */ 
+	   ccissscsi[] to be in line with what's in sd. */
 
 	int i,j, found, changes=0;
 	struct cciss_scsi_dev_t *csd;
@@ -550,7 +546,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h, int hostno,
 	if (hostno != -1)  /* if it's not the first time... */
 		sh = h->scsi_ctlr->scsi_host;
 
-	/* find any devices in ccissscsi[] that are not in 
+	/* find any devices in ccissscsi[] that are not in
 	   sd[] and remove them from ccissscsi[] */
 
 	i = 0;
@@ -570,7 +566,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h, int hostno,
 			}
 		}
 
-		if (found == 0) { /* device no longer present. */ 
+		if (found == 0) { /* device no longer present. */
 			changes++;
 			cciss_scsi_remove_entry(h, hostno, i,
 				removed, &nremoved);
@@ -596,12 +592,12 @@ adjust_cciss_scsi_table(ctlr_info_t *h, int hostno,
 				sizeof(csd->model));
 			memcpy(csd->revision, sd[j].revision,
 				sizeof(csd->revision));
-		} else 		/* device is same as it ever was, */
+		} else		/* device is same as it ever was, */
 			i++;	/* so just move along. */
 	}
 
 	/* Now, make sure every device listed in sd[] is also
- 	   listed in ccissscsi[], adding them if they aren't found */
+	   listed in ccissscsi[], adding them if they aren't found */
 
 	for (i=0;i<nsds;i++) {
 		found=0;
@@ -612,7 +608,7 @@ adjust_cciss_scsi_table(ctlr_info_t *h, int hostno,
 				if (device_is_the_same(&sd[i], csd))
 					found=2;	/* found device */
 				else
-					found=1; 	/* found a bug. */
+					found=1;	/* found a bug. */
 				break;
 			}
 		}
@@ -699,14 +695,14 @@ lookup_scsi3addr(ctlr_info_t *h, int bus, int target, int lun, char *scsi3addr)
 	return -1;
 }
 
-static void 
+static void
 cciss_scsi_setup(ctlr_info_t *h)
 {
 	struct cciss_scsi_adapter_data_t * shba;
 
 	ccissscsi[h->ctlr].ndevices = 0;
 	shba = (struct cciss_scsi_adapter_data_t *)
-		kmalloc(sizeof(*shba), GFP_KERNEL);	
+		kmalloc(sizeof(*shba), GFP_KERNEL);
 	if (shba == NULL)
 		return;
 	shba->scsi_host = NULL;
@@ -742,7 +738,7 @@ static void complete_scsi_command(CommandList_struct *c, int timeout,
 	if (c->Header.SGTotal > h->max_cmd_sgentries)
 		cciss_unmap_sg_chain_block(h, c);
 
-	cmd->result = (DID_OK << 16); 		/* host byte */
+	cmd->result = (DID_OK << 16);		/* host byte */
 	cmd->result |= (COMMAND_COMPLETE << 8);	/* msg byte */
 	/* cmd->result |= (GOOD < 1); */		/* status byte */
 
@@ -751,29 +747,28 @@ static void complete_scsi_command(CommandList_struct *c, int timeout,
 
 	/* copy the sense data whether we need to or not. */
 
-	memcpy(cmd->sense_buffer, ei->SenseInfo, 
+	memcpy(cmd->sense_buffer, ei->SenseInfo,
 		ei->SenseLen > SCSI_SENSE_BUFFERSIZE ?
-			SCSI_SENSE_BUFFERSIZE : 
+			SCSI_SENSE_BUFFERSIZE :
 			ei->SenseLen);
 	scsi_set_resid(cmd, ei->ResidualCnt);
 
-	if(ei->CommandStatus != 0) 
-	{ /* an error has occurred */ 
+	if(ei->CommandStatus != 0)
+	{ /* an error has occurred */
 		switch(ei->CommandStatus)
 		{
 			case CMD_TARGET_STATUS:
 				/* Pass it up to the upper layers... */
 				if( ei->ScsiStatus)
-                		{
+				{
 #if 0
-                    			printk(KERN_WARNING "cciss: cmd %p "
+					printk(KERN_WARNING "cciss: cmd %p "
 						"has SCSI Status = %x\n",
 						c, ei->ScsiStatus);
 #endif
-					cmd->result |= (ei->ScsiStatus << 1);
-                		}
+				}
 				else {  /* scsi status is zero??? How??? */
-					
+
 	/* Ordinarily, this case should never happen, but there is a bug
 	   in some released firmware revisions that allows it to happen
 	   if, for example, a 4100 backplane loses power and the tape
@@ -796,7 +791,7 @@ static void complete_scsi_command(CommandList_struct *c, int timeout,
 				/* print_bytes(c, sizeof(*c), 1, 0);
 				print_cmd(c); */
      /* We get CMD_INVALID if you address a non-existent tape drive instead
-	of a selection timeout (no response).  You will see this if you yank 
+	of a selection timeout (no response).  You will see this if you yank
 	out a tape drive, then try to access it. This is kind of a shame
 	because it means that any other CMD_INVALID (e.g. driver bug) will
 	get interpreted as a missing target. */
@@ -806,12 +801,12 @@ static void complete_scsi_command(CommandList_struct *c, int timeout,
 			case CMD_PROTOCOL_ERR:
 				dev_warn(&h->pdev->dev,
 					"%p has protocol error\n", c);
-                        break;
+			break;
 			case CMD_HARDWARE_ERR:
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
 					"%p had hardware error\n", c);
-                        break;
+			break;
 			case CMD_CONNECTION_LOST:
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
@@ -844,7 +839,7 @@ static void complete_scsi_command(CommandList_struct *c, int timeout,
 				cmd->result = DID_ERROR << 16;
 				dev_warn(&h->pdev->dev,
 					"%p returned unknown status %x\n", c,
-						ei->CommandStatus); 
+						ei->CommandStatus);
 		}
 	}
 	cmd->scsi_done(cmd);
@@ -860,14 +855,14 @@ cciss_scsi_detect(ctlr_info_t *h)
 	sh = scsi_host_alloc(&cciss_driver_template, sizeof(struct ctlr_info *));
 	if (sh == NULL)
 		goto fail;
-	sh->io_port = 0;	// good enough?  FIXME, 
+	sh->io_port = 0;	// good enough?  FIXME,
 	sh->n_io_port = 0;	// I don't think we use these two...
-	sh->this_id = SELF_SCSI_ID;  
-	sh->can_queue = cciss_tape_cmds;
+	sh->this_id = SELF_SCSI_ID;
 	sh->sg_tablesize = h->maxsgentries;
+	sh->can_queue = cciss_tape_cmds;
 	sh->max_cmd_len = MAX_COMMAND_SIZE;
 
-	((struct cciss_scsi_adapter_data_t *) 
+	((struct cciss_scsi_adapter_data_t *)
 		h->scsi_ctlr)->scsi_host = sh;
 	sh->hostdata[0] = (unsigned long) h;
 	sh->irq = h->intr[SIMPLE_MODE_INT];
@@ -919,7 +914,7 @@ cciss_map_one(struct pci_dev *pdev,
 static int
 cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 			CommandList_struct *c,
-			unsigned char *scsi3addr, 
+			unsigned char *scsi3addr,
 			unsigned char *cdb,
 			unsigned char cdblen,
 			unsigned char *buf, int bufsize,
@@ -934,7 +929,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 	c->Header.Tag.lower = c->busaddr;  /* Use k. address of cmd as tag */
 	// Fill in the request block...
 
-	/* printk("Using scsi3addr 0x%02x%0x2%0x2%0x2%0x2%0x2%0x2%0x2\n", 
+	/* printk("Using scsi3addr 0x%02x%0x2%0x2%0x2%0x2%0x2%0x2%0x2\n",
 		scsi3addr[0], scsi3addr[1], scsi3addr[2], scsi3addr[3],
 		scsi3addr[4], scsi3addr[5], scsi3addr[6], scsi3addr[7]); */
 
@@ -948,7 +943,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 
 	/* Fill in the SG list and do dma mapping */
 	cciss_map_one(h->pdev, c, (unsigned char *) buf,
-			bufsize, DMA_FROM_DEVICE); 
+			bufsize, DMA_FROM_DEVICE);
 
 	c->waiting = &wait;
 	enqueue_cmd_and_start_io(h, c);
@@ -959,7 +954,7 @@ cciss_scsi_do_simple_cmd(ctlr_info_t *h,
 	return(0);
 }
 
-static void 
+static void
 cciss_scsi_interpret_error(ctlr_info_t *h, CommandList_struct *c)
 {
 	ErrorInfo_struct *ei;
@@ -1049,7 +1044,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, unsigned char *scsi3addr,
 	spin_unlock_irqrestore(&h->lock, flags);
 
 	if (c == NULL) {			/* trouble... */
-		printk("cmd_alloc returned NULL!\n");
+		dev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");
 		return -1;
 	}
 
@@ -1066,7 +1061,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, unsigned char *scsi3addr,
 
 	if (rc != 0) return rc; /* something went wrong */
 
-	if (ei->CommandStatus != 0 && 
+	if (ei->CommandStatus != 0 &&
 	    ei->CommandStatus != CMD_DATA_UNDERRUN) {
 		cciss_scsi_interpret_error(h, c);
 		rc = -1;
@@ -1074,7 +1069,7 @@ cciss_scsi_do_inquiry(ctlr_info_t *h, unsigned char *scsi3addr,
 	spin_lock_irqsave(&h->lock, flags);
 	scsi_cmd_free(h, c);
 	spin_unlock_irqrestore(&h->lock, flags);
-	return rc;	
+	return rc;
 }
 
 /* Get the device id from inquiry page 0x83 */
@@ -1103,7 +1098,7 @@ cciss_scsi_do_report_phys_luns(ctlr_info_t *h,
 	int rc;
 	CommandList_struct *c;
 	unsigned char cdb[12];
-	unsigned char scsi3addr[8]; 
+	unsigned char scsi3addr[8];
 	ErrorInfo_struct *ei;
 	unsigned long flags;
 
@@ -1111,7 +1106,7 @@ cciss_scsi_do_report_phys_luns(ctlr_info_t *h,
 	c = scsi_cmd_alloc(h);
 	spin_unlock_irqrestore(&h->lock, flags);
 	if (c == NULL) {			/* trouble... */
-		printk("cmd_alloc returned NULL!\n");
+		dev_warn(&h->pdev->dev, "scsi_cmd_alloc returned NULL!\n");
 		return -1;
 	}
 
@@ -1130,14 +1125,14 @@ cciss_scsi_do_report_phys_luns(ctlr_info_t *h,
 	cdb[11] = 0;
 
 	rc = cciss_scsi_do_simple_cmd(h, c, scsi3addr,
-				cdb, 12, 
-				(unsigned char *) buf, 
+				cdb, 12,
+				(unsigned char *) buf,
 				bufsize, XFER_READ);
 
 	if (rc != 0) return rc; /* something went wrong */
 
 	ei = c->err_info;
-	if (ei->CommandStatus != 0 && 
+	if (ei->CommandStatus != 0 &&
 	    ei->CommandStatus != CMD_DATA_UNDERRUN) {
 		cciss_scsi_interpret_error(h, c);
 		rc = -1;
@@ -1145,36 +1140,36 @@ cciss_scsi_do_report_phys_luns(ctlr_info_t *h,
 	spin_lock_irqsave(&h->lock, flags);
 	scsi_cmd_free(h, c);
 	spin_unlock_irqrestore(&h->lock, flags);
-	return rc;	
+	return rc;
 }
 
 static void
 cciss_update_non_disk_devices(ctlr_info_t *h, int hostno)
 {
 	/* the idea here is we could get notified from /proc
-	   that some devices have changed, so we do a report 
-	   physical luns cmd, and adjust our list of devices 
+	   that some devices have changed, so we do a report
+	   physical luns cmd, and adjust our list of devices
 	   accordingly.  (We can't rely on the scsi-mid layer just
-	   doing inquiries, because the "busses" that the scsi 
+	   doing inquiries, because the "busses" that the scsi
 	   mid-layer probes are totally fabricated by this driver,
 	   so new devices wouldn't show up.
 
-	   the scsi3addr's of devices won't change so long as the 
-	   adapter is not reset.  That means we can rescan and 
-	   tell which devices we already know about, vs. new 
+	   the scsi3addr's of devices won't change so long as the
+	   adapter is not reset.  That means we can rescan and
+	   tell which devices we already know about, vs. new
 	   devices, vs.  disappearing devices.
 
 	   Also, if you yank out a tape drive, then put in a disk
-	   in it's place, (say, a configured volume from another 
-	   array controller for instance)  _don't_ poke this driver 
-           (so it thinks it's still a tape, but _do_ poke the scsi 
-           mid layer, so it does an inquiry... the scsi mid layer 
+	   in it's place, (say, a configured volume from another
+	   array controller for instance)  _don't_ poke this driver
+           (so it thinks it's still a tape, but _do_ poke the scsi
+           mid layer, so it does an inquiry... the scsi mid layer
            will see the physical disk.  This would be bad.  Need to
-	   think about how to prevent that.  One idea would be to 
+	   think about how to prevent that.  One idea would be to
 	   snoop all scsi responses and if an inquiry repsonse comes
 	   back that reports a disk, chuck it an return selection
 	   timeout instead and adjust our table...  Not sure i like
-	   that though.  
+	   that though.
 
 	 */
 #define OBDR_TAPE_INQ_SIZE 49
@@ -1194,7 +1189,7 @@ cciss_update_non_disk_devices(ctlr_info_t *h, int hostno)
 	currentsd = kzalloc(sizeof(*currentsd) *
 			(CCISS_MAX_SCSI_DEVS_PER_HBA+1), GFP_KERNEL);
 	if (ld_buff == NULL || inq_buff == NULL || currentsd == NULL) {
-		printk(KERN_ERR "cciss: out of memory\n");
+		dev_err(&h->pdev->dev, "out of memory\n");
 		goto out;
 	}
 	this_device = &currentsd[CCISS_MAX_SCSI_DEVS_PER_HBA];
@@ -1202,20 +1197,20 @@ cciss_update_non_disk_devices(ctlr_info_t *h, int hostno)
 		ch = &ld_buff->LUNListLength[0];
 		num_luns = ((ch[0]<<24) | (ch[1]<<16) | (ch[2]<<8) | ch[3]) / 8;
 		if (num_luns > CISS_MAX_PHYS_LUN) {
-			printk(KERN_WARNING 
-				"cciss: Maximum physical LUNs (%d) exceeded.  "
-				"%d LUNs ignored.\n", CISS_MAX_PHYS_LUN, 
+			dev_warn(&h->pdev->dev,
+				"Maximum physical LUNs (%d) exceeded.  "
+				"%d LUNs ignored.\n", CISS_MAX_PHYS_LUN,
 				num_luns - CISS_MAX_PHYS_LUN);
 			num_luns = CISS_MAX_PHYS_LUN;
 		}
 	}
 	else {
-		printk(KERN_ERR  "cciss: Report physical LUNs failed.\n");
+		dev_err(&h->pdev->dev, "Report physical LUNs failed.\n");
 		goto out;
 	}
 
 
-	/* adjust our table of devices */	
+	/* adjust our table of devices */
 	for (i = 0; i < num_luns; i++) {
 		/* for each physical lun, do an inquiry */
 		if (ld_buff->LUN[i][3] & 0xC0) continue;
@@ -1266,15 +1261,15 @@ cciss_update_non_disk_devices(ctlr_info_t *h, int hostno)
 		  case 0x01: /* sequential access, (tape) */
 		  case 0x08: /* medium changer */
 			if (ncurrent >= CCISS_MAX_SCSI_DEVS_PER_HBA) {
-				printk(KERN_INFO "cciss%d: %s ignored, "
-					"too many devices.\n", h->ctlr,
+				dev_info(&h->pdev->dev, "%s ignored, "
+					"too many devices.\n",
 					scsi_device_type(this_device->devtype));
 				break;
 			}
 			currentsd[ncurrent] = *this_device;
 			ncurrent++;
 			break;
-		  default: 
+		  default:
 			break;
 		}
 	}
@@ -1313,9 +1308,9 @@ cciss_scsi_user_command(ctlr_info_t *h, int hostno, char *buffer, int length)
 static int
 cciss_scsi_proc_info(struct Scsi_Host *sh,
 		char *buffer, /* data buffer */
-		char **start, 	   /* where data in buffer starts */
+		char **start,	   /* where data in buffer starts */
 		off_t offset,	   /* offset from start of imaginary file */
-		int length, 	   /* length of data in buffer */
+		int length,	   /* length of data in buffer */
 		int func)	   /* 0 == read, 1 == write */
 {
 
@@ -1352,19 +1347,19 @@ cciss_scsi_proc_info(struct Scsi_Host *sh,
 				sd->scsi3addr[6], sd->scsi3addr[7]);
 		}
 		datalen = buflen - offset;
-		if (datalen < 0) { 	/* they're reading past EOF. */
+		if (datalen < 0) {	/* they're reading past EOF. */
 			datalen = 0;
-			*start = buffer+buflen;	
+			*start = buffer+buflen;
 		} else
 			*start = buffer + offset;
 		return(datalen);
-	} else 	/* User is writing to /proc/scsi/cciss*?/?*  ... */
+	} else	/* User is writing to /proc/scsi/cciss*?/?*  ... */
 		return cciss_scsi_user_command(h, sh->host_no,
-			buffer, length);	
-} 
+			buffer, length);
+}
 
-/* cciss_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci 
-   dma mapping  and fills in the scatter gather entries of the 
+/* cciss_scatter_gather takes a struct scsi_cmnd, (cmd), and does the pci
+   dma mapping  and fills in the scatter gather entries of the
    cciss command, c. */
 
 static void cciss_scatter_gather(ctlr_info_t *h, CommandList_struct *c,
@@ -1460,7 +1455,7 @@ cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmn
 
 	// Fill in the command list header
 
-	cmd->scsi_done = done;    // save this for use by completion code 
+	cmd->scsi_done = done;    // save this for use by completion code
 
 	/* save c in case we have to abort it */
 	cmd->host_scribble = (unsigned char *) c;
@@ -1470,7 +1465,7 @@ cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmn
 	c->Header.ReplyQueue = 0;  /* unused in simple mode */
 	memcpy(&c->Header.LUN.LunAddrBytes[0], &scsi3addr[0], 8);
 	c->Header.Tag.lower = c->busaddr;  /* Use k. address of cmd as tag */
-	
+
 	// Fill in the request block...
 
 	c->Request.Timeout = 0;
@@ -1498,15 +1493,15 @@ cciss_scsi_queue_command_lck(struct scsi_cmnd *cmd, void (*done)(struct scsi_cmn
 
 		c->Request.Type.Direction = XFER_RSVD;
 		// This is technically wrong, and cciss controllers should
-		// reject it with CMD_INVALID, which is the most correct 
-		// response, but non-fibre backends appear to let it 
+		// reject it with CMD_INVALID, which is the most correct
+		// response, but non-fibre backends appear to let it
 		// slide by, and give the same results as if this field
 		// were set correctly.  Either way is acceptable for
 		// our purposes here.
 
 		break;
 
-	  default: 
+	  default:
 		dev_warn(&h->pdev->dev, "unknown data direction: %d\n",
 			cmd->sc_data_direction);
 		BUG();
@@ -1530,9 +1525,9 @@ static void cciss_unregister_scsi(ctlr_info_t *h)
 
 	spin_lock_irqsave(&h->lock, flags);
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
-	/* if we weren't ever actually registered, don't unregister */ 
+	/* if we weren't ever actually registered, don't unregister */
 	if (sa->registered) {
 		spin_unlock_irqrestore(&h->lock, flags);
 		scsi_remove_host(sa->scsi_host);
@@ -1540,7 +1535,7 @@ static void cciss_unregister_scsi(ctlr_info_t *h)
 		spin_lock_irqsave(&h->lock, flags);
 	}
 
-	/* set scsi_host to NULL so our detect routine will 
+	/* set scsi_host to NULL so our detect routine will
 	   find us on register */
 	sa->scsi_host = NULL;
 	spin_unlock_irqrestore(&h->lock, flags);
@@ -1556,7 +1551,7 @@ static int cciss_engage_scsi(ctlr_info_t *h)
 
 	spin_lock_irqsave(&h->lock, flags);
 	sa = h->scsi_ctlr;
-	stk = &sa->cmd_stack; 
+	stk = &sa->cmd_stack;
 
 	if (sa->registered) {
 		dev_info(&h->pdev->dev, "SCSI subsystem already engaged.\n");
@@ -1652,13 +1647,13 @@ retry_tur:
 	return rc;
 }
 
-/* Need at least one of these error handlers to keep ../scsi/hosts.c from 
- * complaining.  Doing a host- or bus-reset can't do anything good here. 
+/* Need at least one of these error handlers to keep ../scsi/hosts.c from
+ * complaining.  Doing a host- or bus-reset can't do anything good here.
  * Despite what it might say in scsi_error.c, there may well be commands
  * on the controller, as the cciss driver registers twice, once as a block
  * device for the logical drives, and once as a scsi device, for any tape
  * drives.  So we know there are no commands out on the tape drives, but we
- * don't know there are no commands on the controller, and it is likely 
+ * don't know there are no commands on the controller, and it is likely
  * that there probably are, as the cciss block device is most commonly used
  * as a boot device (embedded controller on HP/Compaq systems.)
 */
@@ -1720,5 +1715,6 @@ static int  cciss_eh_abort_handler(struct scsi_cmnd *scsicmd)
 /* If no tape support, then these become defined out of existence */
 
 #define cciss_scsi_setup(cntl_num)
+static void print_cmd(CommandList_struct *cp) {}
 
 #endif /* CONFIG_CISS_SCSI_TAPE */
diff --git a/drivers/block/cciss_scsi.h b/drivers/block/cciss_scsi.h
index 7b75024..a4c62e8 100644
--- a/drivers/block/cciss_scsi.h
+++ b/drivers/block/cciss_scsi.h
@@ -1,6 +1,6 @@
 /*
  *    Disk Array driver for HP Smart Array controllers, SCSI Tape module.
- *    (C) Copyright 2001, 2007 Hewlett-Packard Development Company, L.P.
+ *    (C) Copyright 2001, 2010 Hewlett-Packard Development Company, L.P.
  *
  *    This program is free software; you can redistribute it and/or modify
  *    it under the terms of the GNU General Public License as published by
@@ -25,30 +25,25 @@
 
 #include <scsi/scsicam.h> /* possibly irrelevant, since we don't show disks */
 
-		// the scsi id of the adapter...
+		/* the scsi id of the adapter... */
 #define SELF_SCSI_ID 15
-		// 15 is somewhat arbitrary, since the scsi-2 bus
-		// that's presented by the driver to the OS is
-		// fabricated.  The "real" scsi-3 bus the 
-		// hardware presents is fabricated too.
-		// The actual, honest-to-goodness physical
-		// bus that the devices are attached to is not 
-		// addressible natively, and may in fact turn
-		// out to be not scsi at all.
+		/* 15 is somewhat arbitrary, since the scsi-2 bus
+		   that's presented by the driver to the OS is
+		   fabricated.  The "real" scsi-3 bus the
+		   hardware presents is fabricated too.
+		   The actual, honest-to-goodness physical
+		   bus that the devices are attached to is not
+		   addressible natively, and may in fact turn
+		   out to be not scsi at all. */
 
-#define SCSI_CCISS_CAN_QUEUE 2
-
-/* 
-
-Note, cmd_per_lun could give us some trouble, so I'm setting it very low.
-Likewise, SCSI_CCISS_CAN_QUEUE is set very conservatively.
+/*
 
-If the upper scsi layer tries to track how many commands we have 
+If the upper scsi layer tries to track how many commands we have
 outstanding, it will be operating under the misapprehension that it is
 the only one sending us requests.  We also have the block interface,
 which is where most requests must surely come from, so the upper layer's
 notion of how many requests we have outstanding will be wrong most or
-all of the time. 
+all of the time.
 
 Note, the normal SCSI mid-layer error handling doesn't work well
 for this driver because 1) it takes the io_request_lock before
@@ -78,6 +73,5 @@ struct cciss_scsi_hba_t {
 #define CCISS_MAX_SCSI_DEVS_PER_HBA 16
 	struct cciss_scsi_dev_t dev[CCISS_MAX_SCSI_DEVS_PER_HBA];
 };
-
 #endif /* _CCISS_SCSI_H_ */
 #endif /* CONFIG_CISS_SCSI_TAPE */
diff --git a/include/linux/Kbuild b/include/linux/Kbuild
index a2cd889..36d3a9a 100644
--- a/include/linux/Kbuild
+++ b/include/linux/Kbuild
@@ -15,6 +15,7 @@ header-y += netfilter_bridge/
 header-y += netfilter_ipv4/
 header-y += netfilter_ipv6/
 header-y += usb/
+header-y += cciss_defs.h
 
 header-y += affs_hardblocks.h
 header-y += aio_abi.h
diff --git a/include/linux/cciss_ioctl.h b/include/linux/cciss_ioctl.h
index 986493f..48078c3 100644
--- a/include/linux/cciss_ioctl.h
+++ b/include/linux/cciss_ioctl.h
@@ -14,7 +14,7 @@ typedef struct _cciss_pci_info_struct
 	unsigned char 	dev_fn;
 	unsigned short	domain;
 	__u32 		board_id;
-} cciss_pci_info_struct; 
+} cciss_pci_info_struct;
 
 typedef struct _cciss_coalint_struct
 {
@@ -40,7 +40,7 @@ typedef __u32 DriverVer_type;
 typedef struct _IOCTL_Command_struct {
   LUNAddr_struct	   LUN_info;
   RequestBlock_struct      Request;
-  ErrorInfo_struct  	   error_info; 
+  ErrorInfo_struct  	   error_info;
   WORD			   buf_size;  /* size in bytes of the buf */
   BYTE			   __user *buf;
 } IOCTL_Command_struct;
@@ -77,7 +77,7 @@ typedef struct _LogvolInfo_struct{
 #define CCISS_PASSTHRU	   _IOWR(CCISS_IOC_MAGIC, 11, IOCTL_Command_struct)
 #define CCISS_DEREGDISK	   _IO(CCISS_IOC_MAGIC, 12)
 
-/* no longer used... use REGNEWD instead */ 
+/* no longer used... use REGNEWD instead */
 #define CCISS_REGNEWDISK  _IOW(CCISS_IOC_MAGIC, 13, int)
 
 #define CCISS_REGNEWD	   _IO(CCISS_IOC_MAGIC, 14)
@@ -112,4 +112,4 @@ typedef struct _BIG_IOCTL32_Command_struct {
 
 #endif /* CONFIG_COMPAT */
 #endif /* __KERNEL__ */
-#endif  
+#endif
-- 
1.6.0.2

