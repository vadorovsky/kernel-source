From: Anjali Singhai Jain <anjali.singhai@intel.com>
Date: Wed, 18 Dec 2013 13:45:49 +0000
Subject: [PATCH v3 156/474] i40e: Re-enable interrupt on ICR0
Patch-mainline: v3.14-rc1
Git-commit: 5e8230663d7010fcb43f176b9cc65aecbdcadbc8
References: bsc#909484 FATE#317397

The hardware can occasionally give an interrupt on the misc
queue for which there is no driver work to do.  In that case
the driver was not re-enabling interrupts even though they
were auto masked by hardware.  This left interrupts disabled
on this queue.

Re-enable the interrupt whenever leaving this function.

Signed-off-by: Anjali Singhai Jain <anjali.singhai@intel.com>
Signed-off-by: Jesse Brandeburg <jesse.brandeburg@intel.com>
Tested-by: Kavindya Deegala <kavindya.s.deegala@intel.com>
Signed-off-by: Jeff Kirsher <jeffrey.t.kirsher@intel.com>
Acked-by: David Chang <dchang@suse.com>
---
 drivers/net/ethernet/intel/i40e/i40e_main.c |   10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

--- a/drivers/net/ethernet/intel/i40e/i40e_main.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_main.c
@@ -2752,16 +2752,16 @@ static irqreturn_t i40e_intr(int irq, vo
 {
 	struct i40e_pf *pf = (struct i40e_pf *)data;
 	struct i40e_hw *hw = &pf->hw;
+	irqreturn_t ret = IRQ_NONE;
 	u32 icr0, icr0_remaining;
 	u32 val, ena_mask;
 
 	icr0 = rd32(hw, I40E_PFINT_ICR0);
+	ena_mask = rd32(hw, I40E_PFINT_ICR0_ENA);
 
 	/* if sharing a legacy IRQ, we might get called w/o an intr pending */
 	if ((icr0 & I40E_PFINT_ICR0_INTEVENT_MASK) == 0)
-		return IRQ_NONE;
-
-	ena_mask = rd32(hw, I40E_PFINT_ICR0_ENA);
+		goto enable_intr;
 
 	/* if interrupt but no bits showing, must be SWINT */
 	if (((icr0 & ~I40E_PFINT_ICR0_INTEVENT_MASK) == 0) ||
@@ -2837,7 +2837,9 @@ static irqreturn_t i40e_intr(int irq, vo
 		}
 		ena_mask &= ~icr0_remaining;
 	}
+	ret = IRQ_HANDLED;
 
+enable_intr:
 	/* re-enable interrupt causes */
 	wr32(hw, I40E_PFINT_ICR0_ENA, ena_mask);
 	if (!test_bit(__I40E_DOWN, &pf->state)) {
@@ -2845,7 +2847,7 @@ static irqreturn_t i40e_intr(int irq, vo
 		i40e_irq_dynamic_enable_icr0(pf);
 	}
 
-	return IRQ_HANDLED;
+	return ret;
 }
 
 /**
