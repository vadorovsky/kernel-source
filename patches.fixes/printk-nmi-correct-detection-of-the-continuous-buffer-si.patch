From: Petr Mladek <pmladek@suse.cz>
Date: Wed, 18 Jun 2014 14:50:35 +0200
Subject: [PATCH] printk: correct detection of the continuous buffer size
 (bnc#883067)
Patch-mainline: Depends on the printk/NMI patch set
References: bnc#831949, bnc#883067

The commit c600befeb2f3bdbf76191f (printk: safe printing in NMI context
(bnc#831949)) does crazy thing to initialize the buffer in "struct printk_cont".
The buffer is statically defined outside of the structure and the pointer is
used when the structure is initialized.

The result of the above is that sizeof(cont->buf) returns 1. Then cont_add()
function thinks that there is not enough space and refuses to concatenate
the continuous lines. Each piece is flushed separately and "dmesg" shows them
separate as well.

This patch puts the static buffer size definition back to the "struct printk".
The same buffer is always connected with the same structure and there is no
reason for the crazy hackery.

Then the sizeof() returns the real buffer size, continuous lines are correctly
handled and "dmesg" output is back in normal.

Signed-off-by: Petr Mladek <pmladek@suse.cz>
---
 kernel/printk/printk.c | 19 +++++--------------
 1 file changed, 5 insertions(+), 14 deletions(-)

--- a/kernel/printk/printk.c
+++ b/kernel/printk/printk.c
@@ -278,6 +278,8 @@ struct printk_log {
 };
 
 #ifdef CONFIG_PRINTK
+#define PREFIX_MAX		32
+#define LOG_LINE_MAX		1024 - PREFIX_MAX
 /*
  * Continuation lines are buffered, and not committed to the record buffer
  * until the line is complete, or a race forces it. The line fragments
@@ -285,7 +287,7 @@ struct printk_log {
  * reached the console in case of a kernel crash.
  */
 struct printk_cont {
-	char *buf;
+	char buf[LOG_LINE_MAX];
 	size_t len;			/* length == 0 means unused buffer */
 	size_t cons;			/* bytes written to console */
 	struct task_struct *owner;	/* task of first print*/
@@ -334,9 +336,6 @@ static u32 nmi_merge_idx;
 static u64 clear_seq;
 static u32 clear_idx;
 
-#define PREFIX_MAX		32
-#define LOG_LINE_MAX		1024 - PREFIX_MAX
-
 /* record buffer */
 #if defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
 #define LOG_ALIGN 4
@@ -346,13 +345,9 @@ static u32 clear_idx;
 #define __LOG_BUF_LEN (1 << CONFIG_LOG_BUF_SHIFT)
 #define __LOG_CPU_MAX_BUF_LEN (1 << CONFIG_LOG_CPU_MAX_BUF_SHIFT)
 static char __log_buf[__LOG_BUF_LEN] __aligned(LOG_ALIGN);
-static char __main_cont_buf[LOG_LINE_MAX];
 static char *log_buf = __log_buf;
 static u32 log_buf_len = __LOG_BUF_LEN;
-
-static struct printk_cont main_cont = {
-	.buf = __main_cont_buf,
-};
+static struct printk_cont main_cont;
 
 /*
  * NMI ring buffer must be used if we are in NMI context and the lock for
@@ -360,13 +355,9 @@ static struct printk_cont main_cont = {
  * The content of the NMI buffer is moved to the main buffer on the first
  * occasion.
  */
-static char __nmi_cont_buf[LOG_LINE_MAX];
 static char *nmi_log_buf;
 static u32 nmi_log_buf_len = __LOG_BUF_LEN;
-
-static struct printk_cont nmi_cont = {
-	.buf = __nmi_cont_buf,
-};
+static struct printk_cont nmi_cont;
 
 /*
  * Byte operations needed to manipulate index and sequence numbers for the NMI
