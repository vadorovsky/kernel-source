From 876bc74c75291f98517146f3e6514c0dea989c5c Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Fri, 21 Sep 2012 19:45:19 +0200
Subject: net: prevent NULL dereference in check_peer_redir()
Patch-mainline: Never, upstream fix unusable
References: bnc#776044 bnc#784576

Commit f39925db (ipv4: Cache learned redirect information in
inetpeer) introduced a race condition in access to neighbour
field of struct. This was later fixed in upstream by protecting
it by RCU. However, the fix required more follow-up fixes and
there were still many places where neighbour was accessed
without any protection until the neighbour field itself was
removed in 3.6-rc1.

This patch does only minimal protection against NULL pointer
dereference in check_peer_redir() and potential reference leak
in arp_bind_neighbour() and dn_rt_set_next_hop().

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/decnet/dn_route.c |    6 +++++-
 net/ipv4/arp.c        |    6 +++++-
 net/ipv4/route.c      |    6 ++++--
 3 files changed, 14 insertions(+), 4 deletions(-)

diff --git a/net/decnet/dn_route.c b/net/decnet/dn_route.c
index 2949ca4..a2f5dec 100644
--- a/net/decnet/dn_route.c
+++ b/net/decnet/dn_route.c
@@ -834,10 +834,14 @@ static int dn_rt_set_next_hop(struct dn_route *rt, struct dn_fib_res *res)
 	rt->rt_type = res->type;
 
 	if (dev != NULL && rt->dst.neighbour == NULL) {
+		struct neighbour *old_n;
+
 		n = __neigh_lookup_errno(&dn_neigh_table, &rt->rt_gateway, dev);
 		if (IS_ERR(n))
 			return PTR_ERR(n);
-		rt->dst.neighbour = n;
+		old_n = xchg(&rt->dst.neighbour, n);
+		if (unlikely(old_n != NULL))
+			neigh_release(old_n);
 	}
 
 	if (dst_metric(&rt->dst, RTAX_MTU) > rt->dst.dev->mtu)
diff --git a/net/ipv4/arp.c b/net/ipv4/arp.c
index 4ae2999..acbbda3 100644
--- a/net/ipv4/arp.c
+++ b/net/ipv4/arp.c
@@ -527,6 +527,8 @@ int arp_bind_neighbour(struct dst_entry *dst)
 		return -EINVAL;
 	if (n == NULL) {
 		__be32 nexthop = ((struct rtable *)dst)->rt_gateway;
+		struct neighbour *old_n;
+
 		if (dev->flags & (IFF_LOOPBACK | IFF_POINTOPOINT))
 			nexthop = 0;
 		n = __neigh_lookup_errno(
@@ -537,7 +539,9 @@ int arp_bind_neighbour(struct dst_entry *dst)
 					 &arp_tbl, &nexthop, dev);
 		if (IS_ERR(n))
 			return PTR_ERR(n);
-		dst->neighbour = n;
+		old_n = xchg(&dst->neighbour, n);
+		if (unlikely(old_n != NULL))
+			neigh_release(old_n);
 	}
 	return 0;
 }
diff --git a/net/ipv4/route.c b/net/ipv4/route.c
index 7abe771..106eed9 100644
--- a/net/ipv4/route.c
+++ b/net/ipv4/route.c
@@ -1369,11 +1369,13 @@ static int check_peer_redir(struct dst_entry *dst, struct inet_peer *peer)
 {
 	struct rtable *rt = (struct rtable *) dst;
 	__be32 orig_gw = rt->rt_gateway;
+	struct neighbour *neigh;
 
 	dst_confirm(&rt->dst);
 
-	neigh_release(rt->dst.neighbour);
-	rt->dst.neighbour = NULL;
+	neigh = xchg(&rt->dst.neighbour, NULL);
+	if (neigh)
+		neigh_release(neigh);
 
 	rt->rt_gateway = peer->redirect_learned.a4;
 	if (arp_bind_neighbour(&rt->dst) ||
-- 
1.7.10.4

