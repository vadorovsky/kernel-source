From: NeilBrown <neilb@suse.de>
Date: Thu, 31 Oct 2013 16:06:06 +1100
Subject: [PATCH] SUNRPC: close a rare race in xs_tcp_setup_socket.
References: bnc#794824
Patch-mainline: submitted for 3.13

We have one report of a crash in xs_tcp_setup_socket.
The call path to the crash is:

  xs_tcp_setup_socket -> inet_stream_connect -> lock_sock_nested.

The 'sock' passed to that last function is NULL.

The only way I can see this happening is a concurrent call to
xs_close:

  xs_close -> xs_reset_transport -> sock_release -> inet_release

inet_release sets:
   sock->sk = NULL;
inet_stream_connect calls
   lock_sock(sock->sk);
which gets NULL.

All calls to xs_close are protected by XPRT_LOCKED as are most
activations of the workqueue which runs xs_tcp_setup_socket.
The exception is xs_tcp_schedule_linger_timeout.

So presumably the timeout queued by the later fires exactly when some
other code runs xs_close().

To protect against this we can move the cancel_delayed_work_sync()
call from xs_destory() to xs_close().

As xs_close is never called from the worker scheduled on
->connect_worker, this can never deadlock.

Signed-off-by: NeilBrown <neilb@suse.de>

---
 net/sunrpc/xprtsock.c |    6 ++----
 1 file changed, 2 insertions(+), 4 deletions(-)

--- linux-3.0-SLE11-SP2.orig/net/sunrpc/xprtsock.c
+++ linux-3.0-SLE11-SP2/net/sunrpc/xprtsock.c
@@ -818,6 +818,8 @@ static void xs_close(struct rpc_xprt *xp
 
 	dprintk("RPC:       xs_close xprt %p\n", xprt);
 
+	cancel_delayed_work_sync(&transport->connect_worker);
+
 	xs_reset_transport(transport);
 	xprt->reestablish_timeout = 0;
 
@@ -844,12 +846,8 @@ static void xs_tcp_close(struct rpc_xprt
  */
 static void xs_destroy(struct rpc_xprt *xprt)
 {
-	struct sock_xprt *transport = container_of(xprt, struct sock_xprt, xprt);
-
 	dprintk("RPC:       xs_destroy xprt %p\n", xprt);
 
-	cancel_delayed_work_sync(&transport->connect_worker);
-
 	xs_close(xprt);
 	xs_free_peer_addresses(xprt);
 	xprt_free(xprt);
