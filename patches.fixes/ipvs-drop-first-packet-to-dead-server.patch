From: Jiri Bohac <jbohac@suse.cz>
Subject: ipvs: drop first packet to dead server
References: bsc#946078
Patch-mainline: not yet

Since commit dc7b3eb9 (ipvs: Fix reuse connection if real server is dead),
new connections to dead servers are redistributed immediately to new servers.
The old connection is expired using ip_vs_conn_expire_now(), which sets the connection timer
to expire immediately. 

However, before the timer callback (ip_vs_conn_expire) is run to clean the connection's conntrack entry,
the new redistributed connection may already be established and its conntrack removed instead.

Fix this by dropping the first packet of the new connection instead, like we do
when the destination server is not available. The timer will delete the old conntrack entry
before the first packet of the new connection is retransmitted.

Signed-off-by: Jiri Bohac <jbohac@suse.cz>


diff --git a/include/net/ip_vs.h b/include/net/ip_vs.h
index 3538fd9..15d520e 100644
--- a/include/net/ip_vs.h
+++ b/include/net/ip_vs.h
@@ -1507,6 +1507,24 @@ static inline void ip_vs_conn_drop_conntrack(struct ip_vs_conn *cp)
 /* CONFIG_IP_VS_NFCT */
 #endif
 
+/* Really using conntrack? */
+static inline bool ip_vs_conn_uses_conntrack(struct ip_vs_conn *cp,
+					struct sk_buff *skb)
+{
+#ifdef CONFIG_IP_VS_NFCT
+	enum ip_conntrack_info ctinfo;
+	struct nf_conn *ct;
+
+	if (!(cp->flags & IP_VS_CONN_F_NFCT))
+		return false;
+	ct = nf_ct_get(skb, &ctinfo);
+	if (ct && !nf_ct_is_untracked(ct))
+		return true;
+#endif
+	return false;
+}
+
+
 static inline unsigned int
 ip_vs_dest_conn_overhead(struct ip_vs_dest *dest)
 {
diff --git a/net/netfilter/ipvs/ip_vs_core.c b/net/netfilter/ipvs/ip_vs_core.c
index 8646cb9..c19513e 100644
--- a/net/netfilter/ipvs/ip_vs_core.c
+++ b/net/netfilter/ipvs/ip_vs_core.c
@@ -1609,7 +1609,10 @@ ip_vs_in(unsigned int hooknum, struct sk_buff *skb, int af)
 	    is_new_conn(skb, &iph)) {
 		ip_vs_conn_expire_now(cp);
 		__ip_vs_conn_put(cp);
-		cp = NULL;
+		if (ip_vs_conn_uses_conntrack(cp, skb))
+			return NF_DROP;
+		else
+			cp = NULL;
 	}
 
 	if (unlikely(!cp) && !iph.fragoffs) {
