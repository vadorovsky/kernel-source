From: NeilBrown <neilb@suse.com>
Subject: Fix handling of re-write-before-commit for mmapped NFS pages.
References: bsc#964201
Patch-mainline: v3.16
Git-Commit: d458138353726ea6dcbc53ae3597e489d0432c25

After a page has been written to the NFS server there is a period while it
is 'unstable' before a 'COMMIT' request is used to commit it.
The nfs_page stays on a list of pending-commits at this time.

If the page is rediried before the COMMIT starts, it needs to be
removed from the commit list as commiting that page which now hasn't
been written would not be meaningful.

If the page is written to with a 'write' systemcall, nfs_try_to_update_request()
performs he necessary call to nfs_clear_request_commit().
However if the page is dirtied via a mmap (or other call to set_page_dirty())
that doesn't happen.

It might make sense to unlink from the commit list in the
->set_page_dirty callback, but that isn't what upstream does.
Instead, nfs_page_async_flush() calls nfs_lock_and_join_request which
unlinks the request if necessary.
This patch makes the same change to nfs_find_and_lock_request(), which is
the equivalent in 3.0

Signed-off-by: NeilBrown <neilb@suse.com>

---
 fs/nfs/write.c |   11 ++++++++++-
 1 file changed, 10 insertions(+), 1 deletion(-)

--- a/fs/nfs/write.c
+++ b/fs/nfs/write.c
@@ -264,6 +264,8 @@ static void nfs_end_page_writeback(struc
 		clear_bdi_congested(&nfss->backing_dev_info, BLK_RW_ASYNC);
 }
 
+static int nfs_clear_request_commit(struct nfs_page *req);
+
 static struct nfs_page *nfs_find_and_lock_request(struct page *page, bool nonblock)
 {
 	struct inode *inode = page_file_mapping(page)->host;
@@ -275,8 +277,15 @@ static struct nfs_page *nfs_find_and_loc
 		req = nfs_page_find_request_locked(NFS_I(inode), page);
 		if (req == NULL)
 			break;
-		if (nfs_set_page_tag_locked(req))
+		if (nfs_set_page_tag_locked(req)) {
+			if (nfs_clear_request_commit(req)) {
+				radix_tree_tag_clear(&NFS_I(inode)->nfs_page_tree,
+						     req->wb_index, NFS_PAGE_TAG_COMMIT);
+				NFS_I(inode)->ncommit--;
+				pnfs_clear_request_commit(req);
+			}
 			break;
+		}
 		/* Note: If we hold the page lock, as is the case in nfs_writepage,
 		 *	 then the call to nfs_set_page_tag_locked() will always
 		 *	 succeed provided that someone hasn't already marked the
