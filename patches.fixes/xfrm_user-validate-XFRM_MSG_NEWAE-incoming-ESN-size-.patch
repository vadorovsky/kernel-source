From: Andy Whitcroft <apw@canonical.com>
Date: Thu, 23 Mar 2017 07:45:44 +0000
Subject: xfrm_user: validate XFRM_MSG_NEWAE incoming ESN size harder
Patch-mainline: Not yet, embargoed
References: CVE-2017-7184 bsc#1030573

When validating the length of the incoming ESN attribute we are using
the contents of the ESN attribute to calculate the minimum size of that
attribute.  We do this before confirming the attribute actually even
has enough data to hold the structure containing the size.  Ensure the
attribute is at least the minimum size of an ESN without bitmap.

Additionally Kees Cook has pointed out that xfrm_replay_state_esn_len()
is subject to wrapping issues.  To ensure we are correctly ensuring that
the two ESN structures are the same size compare both the overall size
as reported by xfrm_replay_state_esn_len() and the internal length are
the same.

CVE-2017-7184
Signed-off-by: Andy Whitcroft <apw@canonical.com>
Acked-by: Michal Kubecek <mkubecek@suse.cz>
---
 net/xfrm/xfrm_user.c | 9 ++++++++-
 1 file changed, 8 insertions(+), 1 deletion(-)

diff --git a/net/xfrm/xfrm_user.c b/net/xfrm/xfrm_user.c
index 0e1f833bc77d..7de612deb39b 100644
--- a/net/xfrm/xfrm_user.c
+++ b/net/xfrm/xfrm_user.c
@@ -409,10 +409,17 @@ static inline int xfrm_replay_verify_len(struct xfrm_replay_state_esn *replay_es
 	if (!replay_esn || !rp)
 		return 0;
 
+	if (nla_len(rp) < sizeof(*up))
+		return -EINVAL;
+
 	up = nla_data(rp);
 	ulen = xfrm_replay_state_esn_len(up);
 
-	if (nla_len(rp) < ulen || xfrm_replay_state_esn_len(replay_esn) != ulen)
+	/* Check the overall length and the internal bitmap length to avoid
+	 * potential overflow. */
+	if (nla_len(rp) < ulen ||
+	    xfrm_replay_state_esn_len(replay_esn) != ulen ||
+	    replay_esn->bmp_len != up->bmp_len)
 		return -EINVAL;
 
 	if (up->replay_window > up->bmp_len * sizeof(__u32) * 8)
-- 
2.12.0

