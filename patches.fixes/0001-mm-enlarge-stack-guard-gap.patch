From 813ac799d7a5de6535fd17bbce8d0c0326eddc9d Mon Sep 17 00:00:00 2001
From: Michal Hocko <mhocko@suse.com>
Date: Fri, 12 May 2017 09:09:30 +0200
Subject: [PATCH] mm: enlarge stack guard gap
Patch-mainline: not yet (security@kernel.org discussion pending)
References: bnc#1039348

Stack guard page is a useful feature to reduce a risk of stack smashing
into a different mapping. We have been using a single page gap which
is sufficient to prevent having stack adjacent to a different mapping.
But this seems to be insufficient in the light of the stack usage in
the userspace. E.g. glibc uses as large as 64kB alloca() in many
commonly used functions. This will become especially dangerous for suid
binaries and the default no limit for the stack size limit because those
applications can be tricked to consume a large portion of the stack and
a single glibc call could jump over the guard page. These attacks are
not theoretical, unfortunatelly.

Make those attacks less probable by increasing the stack guard gap
to 1MB (on systems with 4k pages but make it depend on the page size
because systems with larger base pages might cap stack allocations in
the PAGE_SIZE units) which should cover larger alloca() and VLA stack
allocations. It is obviously not a full fix because the problem is
somehow inherent but it should reduce attack space a lot. One could
argue that the gap size should be configurable from the userspace but
that can be done later on top when somebody finds that the new 1MB is
not suitable or even wrong for some special case applications.

Implementation wise, get rid of check_stack_guard_page and move all the
guard page specific code to expandable_stack_area which always tries to
guarantee the gap. do_anonymous_page then just calls expand_stack. Also
get rid of stack_guard_page_{start,end} and replace them with
stack_guard_area to handle stack population and /proc/<pid>/[s]maps.

This should clean up the code which is quite scattered currently
and therefore justify the change.

Signed-off-by: Michal Hocko <mhocko@suse.com>

---
 arch/ia64/mm/fault.c |    2 
 fs/exec.c            |    3 -
 fs/proc/task_mmu.c   |   11 ++--
 include/linux/mm.h   |   40 +++-----------
 mm/memory.c          |   45 +---------------
 mm/mmap.c            |  140 ++++++++++++++++++++++++++++++++++++++++++++++++---
 6 files changed, 154 insertions(+), 87 deletions(-)

--- a/arch/ia64/mm/fault.c
+++ b/arch/ia64/mm/fault.c
@@ -198,7 +198,7 @@ ia64_do_page_fault (unsigned long addres
 		 */
 		if (address > vma->vm_end + PAGE_SIZE - sizeof(long))
 			goto bad_area;
-		if (expand_upwards(vma, address))
+		if (expand_upwards(vma, address, 0))
 			goto bad_area;
 	}
 	goto good_area;
--- a/fs/exec.c
+++ b/fs/exec.c
@@ -199,7 +199,7 @@ static struct page *get_arg_page(struct
 
 #ifdef CONFIG_STACK_GROWSUP
 	if (write) {
-		ret = expand_downwards(bprm->vma, pos);
+		ret = expand_downwards(bprm->vma, pos, 0);
 		if (ret < 0)
 			return NULL;
 	}
@@ -213,6 +213,7 @@ static struct page *get_arg_page(struct
 		unsigned long size = bprm->vma->vm_end - bprm->vma->vm_start;
 		struct rlimit *rlim;
 
+		size -= stack_guard_gap;
 		acct_arg_size(bprm, size / PAGE_SIZE);
 
 		/*
--- a/fs/proc/task_mmu.c
+++ b/fs/proc/task_mmu.c
@@ -227,11 +227,14 @@ static void show_map_vma(struct seq_file
 
 	/* We don't show the stack guard page in /proc/maps */
 	start = vma->vm_start;
-	if (stack_guard_page_start(vma, start))
-		start += PAGE_SIZE;
 	end = vma->vm_end;
-	if (stack_guard_page_end(vma, end))
-		end -= PAGE_SIZE;
+	if (vma->vm_flags & VM_GROWSDOWN) {
+		if (stack_guard_area(vma, start))
+			start += stack_guard_gap;
+	} else if (vma->vm_flags & VM_GROWSUP) {
+		if (stack_guard_area(vma, end))
+			end -= stack_guard_gap;
+	}
 
 	seq_printf(m, "%08lx-%08lx %c%c%c%c %08llx %02x:%02x %lu %n",
 			start,
--- a/include/linux/mm.h
+++ b/include/linux/mm.h
@@ -1009,34 +1009,6 @@ int set_page_dirty_lock(struct page *pag
 int set_page_dirty_notag(struct page *page);
 int clear_page_dirty_for_io(struct page *page);
 
-/* Is the vma a continuation of the stack vma above it? */
-static inline int vma_growsdown(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_end == addr) && (vma->vm_flags & VM_GROWSDOWN);
-}
-
-static inline int stack_guard_page_start(struct vm_area_struct *vma,
-					     unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSDOWN) &&
-		(vma->vm_start == addr) &&
-		!vma_growsdown(vma->vm_prev, addr);
-}
-
-/* Is the vma a continuation of the stack vma below it? */
-static inline int vma_growsup(struct vm_area_struct *vma, unsigned long addr)
-{
-	return vma && (vma->vm_start == addr) && (vma->vm_flags & VM_GROWSUP);
-}
-
-static inline int stack_guard_page_end(struct vm_area_struct *vma,
-					   unsigned long addr)
-{
-	return (vma->vm_flags & VM_GROWSUP) &&
-		(vma->vm_end == addr) &&
-		!vma_growsup(vma->vm_next, addr);
-}
-
 extern unsigned long move_page_tables(struct vm_area_struct *vma,
 		unsigned long old_addr, struct vm_area_struct *new_vma,
 		unsigned long new_addr, unsigned long len);
@@ -1498,16 +1470,22 @@ unsigned long ra_submit(struct file_ra_s
 			struct address_space *mapping,
 			struct file *filp);
 
+extern unsigned long stack_guard_gap;
 /* Generic expand stack which grows the stack according to GROWS{UP,DOWN} */
 extern int expand_stack(struct vm_area_struct *vma, unsigned long address);
+extern int stack_guard_area(struct vm_area_struct *vma, unsigned long address);
 
 /* CONFIG_STACK_GROWSUP still needs to to grow downwards at some places */
 extern int expand_downwards(struct vm_area_struct *vma,
-		unsigned long address);
+		unsigned long address, unsigned long gap);
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap);
+
 #if VM_GROWSUP
-extern int expand_upwards(struct vm_area_struct *vma, unsigned long address);
+extern int expand_upwards(struct vm_area_struct *vma,
+		unsigned long address, unsigned long gap);
 #else
-  #define expand_upwards(vma, address) do { } while (0)
+  #define expand_upwards(vma, address, gap) do { } while (0)
 #endif
 
 /* Look up the first VMA which satisfies  addr < vm_end,  NULL if none. */
--- a/mm/memory.c
+++ b/mm/memory.c
@@ -1603,12 +1603,6 @@ no_page_table:
 	return page;
 }
 
-static inline int stack_guard_page(struct vm_area_struct *vma, unsigned long addr)
-{
-	return stack_guard_page_start(vma, addr) ||
-	       stack_guard_page_end(vma, addr+PAGE_SIZE);
-}
-
 /**
  * __get_user_pages() - pin user pages in memory
  * @tsk:	task_struct of target task
@@ -1761,7 +1755,7 @@ int __get_user_pages(struct task_struct
 
 				/* For mlock, just skip the stack guard page. */
 				if (foll_flags & FOLL_MLOCK) {
-					if (stack_guard_page(vma, start))
+					if (stack_guard_area(vma, start))
 						goto next_page;
 				}
 				if (foll_flags & FOLL_WRITE)
@@ -3108,40 +3102,6 @@ out_release:
 }
 
 /*
- * This is like a special single-page "expand_{down|up}wards()",
- * except we must first make sure that 'address{-|+}PAGE_SIZE'
- * doesn't hit another vma.
- */
-static inline int check_stack_guard_page(struct vm_area_struct *vma, unsigned long address)
-{
-	address &= PAGE_MASK;
-	if ((vma->vm_flags & VM_GROWSDOWN) && address == vma->vm_start) {
-		struct vm_area_struct *prev = vma->vm_prev;
-
-		/*
-		 * Is there a mapping abutting this one below?
-		 *
-		 * That's only ok if it's the same stack mapping
-		 * that has gotten split..
-		 */
-		if (prev && prev->vm_end == address)
-			return prev->vm_flags & VM_GROWSDOWN ? 0 : -ENOMEM;
-
-		expand_downwards(vma, address - PAGE_SIZE);
-	}
-	if ((vma->vm_flags & VM_GROWSUP) && address + PAGE_SIZE == vma->vm_end) {
-		struct vm_area_struct *next = vma->vm_next;
-
-		/* As VM_GROWSDOWN but s/below/above/ */
-		if (next && next->vm_start == address + PAGE_SIZE)
-			return next->vm_flags & VM_GROWSUP ? 0 : -ENOMEM;
-
-		expand_upwards(vma, address + PAGE_SIZE);
-	}
-	return 0;
-}
-
-/*
  * We enter with non-exclusive mmap_sem (to exclude vma changes,
  * but allow concurrent faults), and pte mapped but not yet locked.
  * We return with mmap_sem still held, but pte unmapped and unlocked.
@@ -3157,7 +3117,8 @@ static int do_anonymous_page(struct mm_s
 	pte_unmap(page_table);
 
 	/* Check if we need to add a guard page to the stack */
-	if (check_stack_guard_page(vma, address) < 0)
+	if ((vma->vm_flags & (VM_GROWSDOWN|VM_GROWSUP)) &&
+			expand_stack(vma, address) < 0)
 		return VM_FAULT_SIGBUS;
 
 	/* Use the zero-page for reads */
--- a/mm/mmap.c
+++ b/mm/mmap.c
@@ -1651,18 +1651,23 @@ out:
  * update accounting. This is shared with both the
  * grow-up and grow-down cases.
  */
-static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow)
+static int acct_stack_growth(struct vm_area_struct *vma, unsigned long size, unsigned long grow,
+		unsigned long gap)
 {
 	struct mm_struct *mm = vma->vm_mm;
 	struct rlimit *rlim = current->signal->rlim;
 	unsigned long new_start;
+	unsigned long actual_size;
 
 	/* address space limit tests */
 	if (!may_expand_vm(mm, grow))
 		return -ENOMEM;
 
 	/* Stack limit test */
-	if (size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
+	actual_size = size;
+ 	if (size && (vma->vm_flags & (VM_GROWSUP | VM_GROWSDOWN)))
+		actual_size -= gap;
+	if (actual_size > ACCESS_ONCE(rlim[RLIMIT_STACK].rlim_cur))
 		return -ENOMEM;
 
 	/* mlock limit tests */
@@ -1702,7 +1707,7 @@ static int acct_stack_growth(struct vm_a
  * PA-RISC uses this for its stack; IA64 for its Register Backing Store.
  * vma is the last one with address > vma->vm_end.  Have to extend vma.
  */
-int expand_upwards(struct vm_area_struct *vma, unsigned long address)
+int expand_upwards(struct vm_area_struct *vma, unsigned long address, unsigned long gap)
 {
 	int error;
 
@@ -1740,7 +1745,7 @@ int expand_upwards(struct vm_area_struct
 
 		error = -ENOMEM;
 		if (vma->vm_pgoff + (size >> PAGE_SHIFT) >= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				vma->vm_end = address;
 				perf_event_mmap(vma);
@@ -1757,7 +1762,7 @@ int expand_upwards(struct vm_area_struct
  * vma is the first one with address < vma->vm_start.  Have to extend vma.
  */
 int expand_downwards(struct vm_area_struct *vma,
-				   unsigned long address)
+				   unsigned long address, unsigned long gap)
 {
 	int error;
 
@@ -1790,7 +1795,7 @@ int expand_downwards(struct vm_area_stru
 
 		error = -ENOMEM;
 		if (grow <= vma->vm_pgoff) {
-			error = acct_stack_growth(vma, size, grow);
+			error = acct_stack_growth(vma, size, grow, gap);
 			if (!error) {
 				vma->vm_start = address;
 				vma->vm_pgoff -= grow;
@@ -1803,10 +1808,65 @@ int expand_downwards(struct vm_area_stru
 	return error;
 }
 
+/* enforced gap between the expanding stack and other mappings. */
+unsigned long stack_guard_gap = 256UL<<PAGE_SHIFT;
+
 #ifdef CONFIG_STACK_GROWSUP
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *next = vma->vm_next;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+
+	address = ALIGN(address, PAGE_SIZE);;
+	if (!next)
+		goto out;
+
+	if (next->vm_flags & VM_GROWSUP) {
+		guard_gap = min(guard_gap, next->vm_start - address);
+		goto out;
+	}
+
+	if (next->vm_start - address < guard_gap)
+		return -ENOMEM;
+out:
+	if (TASK_SIZE - address < guard_gap)
+		guard_gap = TASK_SIZE - address;
+	guard_addr = address + guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
-	return expand_upwards(vma, address);
+	unsigned long gap;
+
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_upwards(vma, address, gap);
+}
+
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
+	struct vm_area_struct *next;
+
+	if (!(vma->vm_flags & VM_GROWSUP))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
+	next = vma->vm_next;
+	if (next && next->vm_flags & VM_GROWSUP)
+		return 0;
+
+	return vma->vm_end - address <= stack_guard_gap;
 }
 
 struct vm_area_struct *
@@ -1826,9 +1886,73 @@ find_extend_vma(struct mm_struct *mm, un
 	return prev;
 }
 #else
+unsigned long expandable_stack_area(struct vm_area_struct *vma,
+		unsigned long address, unsigned long *gap)
+{
+	struct vm_area_struct *prev = vma->vm_prev;
+	unsigned long guard_gap = stack_guard_gap;
+	unsigned long guard_addr;
+
+	address &= PAGE_MASK;
+	if (!prev)
+		goto out;
+
+	/*
+	 * Is there a mapping abutting this one below?
+	 *
+	 * That's only ok if it's the same stack mapping
+	 * that has gotten split or there is sufficient gap
+	 * between mappings
+	 */
+	if (prev->vm_flags & VM_GROWSDOWN) {
+		guard_gap = min(guard_gap, address - prev->vm_end);
+		goto out;
+	}
+
+	if (address - prev->vm_end < guard_gap)
+		return -ENOMEM;
+
+out:
+	/* make sure we won't underflow */
+	if (address < mmap_min_addr)
+		return -ENOMEM;
+	if (address - mmap_min_addr < guard_gap)
+		guard_gap = address - mmap_min_addr;
+
+	guard_addr = address - guard_gap;
+	*gap = guard_gap;
+
+	return guard_addr;
+}
+
 int expand_stack(struct vm_area_struct *vma, unsigned long address)
 {
-	return expand_downwards(vma, address);
+	unsigned long gap;
+
+	address = expandable_stack_area(vma, address, &gap);
+	if (IS_ERR_VALUE(address))
+		return -ENOMEM;
+	return expand_downwards(vma, address, gap);
+}
+
+int stack_guard_area(struct vm_area_struct *vma, unsigned long address)
+{
+	struct vm_area_struct *prev;
+
+	if (!(vma->vm_flags & VM_GROWSDOWN))
+		return 0;
+
+	/*
+	 * strictly speaking there is a guard gap between disjoint stacks
+	 * but the gap is not canonical (it might be smaller) and it is
+	 * reasonably safe to assume that we can ignore that gap for stack
+	 * POPULATE or /proc/<pid>[s]maps purposes
+	 */
+	prev = vma->vm_prev;
+	if (prev && prev->vm_flags & VM_GROWSDOWN)
+		return 0;
+
+	return address - vma->vm_start < stack_guard_gap;
 }
 
 struct vm_area_struct *
