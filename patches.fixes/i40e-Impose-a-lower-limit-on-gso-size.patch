From: Benjamin Poirier <bpoirier@suse.com>
Date: Mon, 30 Jan 2017 18:01:45 -0800
Subject: i40e: Impose a lower limit on gso size
Patch-mainline: Never, alternate version of f114dca2533c for older kernels
References: bsc#985561

Extracted from bsc#985561 comment 136.

Signed-off-by: Benjamin Poirier <bpoirier@suse.com>
---
 drivers/net/ethernet/intel/i40e/i40e_fcoe.c |   34 +++++++++++++++---
 drivers/net/ethernet/intel/i40e/i40e_txrx.c |   51 +++++++++++++++++-----------
 2 files changed, 59 insertions(+), 26 deletions(-)

--- a/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_fcoe.c
@@ -1194,7 +1194,7 @@ static void i40e_fcoe_handle_ddp(struct
 /**
  * i40e_fcoe_tso - set up FCoE TSO
  * @tx_ring:  ring to send buffer on
- * @skb:      send buffer
+ * @first:    pointer to first Tx buffer for xmit
  * @tx_flags: collected send information
  * @hdr_len:  the tso header length
  * @sof: the SOF to indicate class of service
@@ -1207,13 +1207,15 @@ static void i40e_fcoe_handle_ddp(struct
  * code to drop the frame.
  **/
 static int i40e_fcoe_tso(struct i40e_ring *tx_ring,
-			 struct sk_buff *skb,
+			 struct i40e_tx_buffer *first,
 			 u32 tx_flags, u8 *hdr_len, u8 sof)
 {
+	struct sk_buff *skb = first->skb;
 	struct i40e_tx_context_desc *context_desc;
 	u32 cd_type, cd_cmd, cd_tso_len, cd_mss;
 	struct fc_frame_header *fh;
 	u64 cd_type_cmd_tso_mss;
+	u16 gso_segs, gso_size;
 
 	/* must match gso type as FCoE */
 	if (!skb_is_gso(skb))
@@ -1231,6 +1233,21 @@ static int i40e_fcoe_tso(struct i40e_rin
 	*hdr_len = skb_transport_offset(skb) + sizeof(struct fc_frame_header) +
 		   sizeof(struct fcoe_crc_eof);
 
+	/* pull values out of skb_shinfo */
+	gso_size = skb_shinfo(skb)->gso_size;
+	gso_segs = skb_shinfo(skb)->gso_segs;
+
+#ifndef HAVE_NDO_FEATURES_CHECK
+	/* too small a TSO segment size causes problems */
+	if (gso_size < 64) {
+		gso_size = 64;
+		gso_segs = DIV_ROUND_UP(skb->len - *hdr_len, 64);
+	}
+#endif
+	/* update gso size and bytecount with header size */
+	first->gso_segs = gso_segs;
+	first->bytecount += (first->gso_segs - 1) * *hdr_len;
+
 	/* check sof to decide a class 2 or 3 TSO */
 	if (likely(i40e_fcoe_sof_is_class3(sof)))
 		cd_cmd = I40E_FCOE_TX_CTX_DESC_OPCODE_TSO_FC_CLASS3;
@@ -1245,7 +1262,7 @@ static int i40e_fcoe_tso(struct i40e_rin
 	/* fill the field values */
 	cd_type = I40E_TX_DESC_DTYPE_FCOE_CTX;
 	cd_tso_len = skb->len - *hdr_len;
-	cd_mss = skb_shinfo(skb)->gso_size;
+	cd_mss = gso_size;
 	cd_type_cmd_tso_mss =
 		((u64)cd_type  << I40E_TXD_CTX_QW1_DTYPE_SHIFT)     |
 		((u64)cd_cmd     << I40E_TXD_CTX_QW1_CMD_SHIFT)	    |
@@ -1397,6 +1414,9 @@ static netdev_tx_t i40e_fcoe_xmit_frame(
 
 	/* record the location of the first descriptor for this packet */
 	first = &tx_ring->tx_bi[tx_ring->next_to_use];
+	first->skb = skb;
+	first->bytecount = skb->len;
+	first->gso_segs = 1;
 
 	/* FIP is a regular L2 traffic w/o offload */
 	if (skb->protocol == htons(ETH_P_FIP))
@@ -1405,16 +1425,16 @@ static netdev_tx_t i40e_fcoe_xmit_frame(
 	/* check sof and eof, only supports FC Class 2 or 3 */
 	if (i40e_fcoe_fc_sof(skb, &sof) || i40e_fcoe_fc_eof(skb, &eof)) {
 		netdev_err(netdev, "SOF/EOF error:%02x - %02x\n", sof, eof);
-		goto out_drop;
+		goto out_drop_first;
 	}
 
 	/* always do FCCRC for FCoE */
 	tx_flags |= I40E_TX_FLAGS_FCCRC;
 
 	/* check we should do sequence offload */
-	fso = i40e_fcoe_tso(tx_ring, skb, tx_flags, &hdr_len, sof);
+	fso = i40e_fcoe_tso(tx_ring, first, tx_flags, &hdr_len, sof);
 	if (fso < 0)
-		goto out_drop;
+		goto out_drop_first;
 	else if (fso)
 		tx_flags |= I40E_TX_FLAGS_FSO;
 	else
@@ -1427,6 +1447,8 @@ out_send:
 	i40e_maybe_stop_tx(tx_ring, DESC_NEEDED);
 	return NETDEV_TX_OK;
 
+out_drop_first:
+	first->skb = NULL;
 out_drop:
 	dev_kfree_skb_any(skb);
 	return NETDEV_TX_OK;
--- a/drivers/net/ethernet/intel/i40e/i40e_txrx.c
+++ b/drivers/net/ethernet/intel/i40e/i40e_txrx.c
@@ -1814,7 +1814,7 @@ static int i40e_tx_prepare_vlan_flags(st
 /**
  * i40e_tso - set up the tso context descriptor
  * @tx_ring:  ptr to the ring to send
- * @skb:      ptr to the skb we're sending
+ * @first:    pointer to first Tx buffer for xmit
  * @tx_flags: the collected send information
  * @protocol: the send protocol
  * @hdr_len:  ptr to the size of the packet header
@@ -1822,15 +1822,17 @@ static int i40e_tx_prepare_vlan_flags(st
  *
  * Returns 0 if no TSO can happen, 1 if tso is going, or error
  **/
-static int i40e_tso(struct i40e_ring *tx_ring, struct sk_buff *skb,
+static int i40e_tso(struct i40e_ring *tx_ring, struct i40e_tx_buffer *first,
 		    u32 tx_flags, __be16 protocol, u8 *hdr_len,
 		    u64 *cd_type_cmd_tso_mss, u32 *cd_tunneling)
 {
+	struct sk_buff *skb = first->skb;
 	u32 cd_cmd, cd_tso_len, cd_mss;
 	struct ipv6hdr *ipv6h;
 	struct tcphdr *tcph;
 	struct iphdr *iph;
 	u32 l4len;
+	u16 gso_segs, gso_size;
 	int err;
 
 	if (!skb_is_gso(skb))
@@ -1862,10 +1864,23 @@ static int i40e_tso(struct i40e_ring *tx
 		    ? (skb_inner_transport_header(skb) - skb->data)
 		    : skb_transport_offset(skb)) + l4len;
 
+	/* pull values out of skb_shinfo */
+	gso_size = skb_shinfo(skb)->gso_size;
+	gso_segs = skb_shinfo(skb)->gso_segs;
+
+	/* too small a TSO segment size causes problems */
+	if (gso_size < 64) {
+		gso_size = 64;
+		gso_segs = DIV_ROUND_UP(skb->len - *hdr_len, 64);
+	}
+	/* update gso size and bytecount with header size */
+	first->gso_segs = gso_segs;
+	first->bytecount += (first->gso_segs - 1) * *hdr_len;
+
 	/* find the field values */
 	cd_cmd = I40E_TX_CTX_DESC_TSO;
 	cd_tso_len = skb->len - *hdr_len;
-	cd_mss = skb_shinfo(skb)->gso_size;
+	cd_mss = gso_size;
 	*cd_type_cmd_tso_mss |= ((u64)cd_cmd << I40E_TXD_CTX_QW1_CMD_SHIFT) |
 				((u64)cd_tso_len <<
 				 I40E_TXD_CTX_QW1_TSO_LEN_SHIFT) |
@@ -2167,7 +2182,6 @@ static void i40e_tx_map(struct i40e_ring
 	u16 i = tx_ring->next_to_use;
 	u32 td_tag = 0;
 	dma_addr_t dma;
-	u16 gso_segs;
 
 	if (tx_flags & I40E_TX_FLAGS_HW_VLAN) {
 		td_cmd |= I40E_TX_DESC_CMD_IL2TAG1;
@@ -2175,15 +2189,6 @@ static void i40e_tx_map(struct i40e_ring
 			 I40E_TX_FLAGS_VLAN_SHIFT;
 	}
 
-	if (tx_flags & (I40E_TX_FLAGS_TSO | I40E_TX_FLAGS_FSO))
-		gso_segs = skb_shinfo(skb)->gso_segs;
-	else
-		gso_segs = 1;
-
-	/* multiply data chunks by size of headers */
-	first->bytecount = skb->len - hdr_len + (gso_segs * hdr_len);
-	first->gso_segs = gso_segs;
-	first->skb = skb;
 	first->tx_flags = tx_flags;
 
 	dma = dma_map_single(tx_ring->dev, skb->data, size, DMA_TO_DEVICE);
@@ -2327,8 +2332,10 @@ static netdev_tx_t i40e_xmit_frame_ring(
 
 	count = i40e_xmit_descriptor_count(skb);
 	if (i40e_chk_linearize(skb, count)) {
-		if (__skb_linearize(skb))
-			goto out_drop;
+		if (__skb_linearize(skb)) {
+			dev_kfree_skb_any(skb);
+			return NETDEV_TX_OK;
+		}
 		count = TXD_USE_COUNT(skb->len);
 	}
 
@@ -2343,6 +2350,12 @@ static netdev_tx_t i40e_xmit_frame_ring(
 		return NETDEV_TX_BUSY;
 	}
 
+	/* record the location of the first descriptor for this packet */
+	first = &tx_ring->tx_bi[tx_ring->next_to_use];
+	first->skb = skb;
+	first->bytecount = skb->len;
+	first->gso_segs = 1;
+
 	/* prepare the xmit flags */
 	if (i40e_tx_prepare_vlan_flags(skb, tx_ring, &tx_flags))
 		goto out_drop;
@@ -2350,16 +2363,13 @@ static netdev_tx_t i40e_xmit_frame_ring(
 	/* obtain protocol of skb */
 	protocol = vlan_get_protocol(skb);
 
-	/* record the location of the first descriptor for this packet */
-	first = &tx_ring->tx_bi[tx_ring->next_to_use];
-
 	/* setup IPv4/IPv6 offloads */
 	if (protocol == htons(ETH_P_IP))
 		tx_flags |= I40E_TX_FLAGS_IPV4;
 	else if (protocol == htons(ETH_P_IPV6))
 		tx_flags |= I40E_TX_FLAGS_IPV6;
 
-	tso = i40e_tso(tx_ring, skb, tx_flags, protocol, &hdr_len,
+	tso = i40e_tso(tx_ring, first, tx_flags, protocol, &hdr_len,
 		       &cd_type_cmd_tso_mss, &cd_tunneling);
 
 	if (tso < 0)
@@ -2402,7 +2412,8 @@ static netdev_tx_t i40e_xmit_frame_ring(
 	return NETDEV_TX_OK;
 
 out_drop:
-	dev_kfree_skb_any(skb);
+	dev_kfree_skb_any(first->skb);
+	first->skb = NULL;
 	return NETDEV_TX_OK;
 }
 
