Subject: Fix xen build.
From: jbeulich@novell.com
Patch-mainline: n/a

--- sle11sp3.orig/drivers/acpi/acpica/hwsleep.c	2011-04-13 11:25:29.000000000 +0200
+++ sle11sp3/drivers/acpi/acpica/hwsleep.c	2011-01-31 17:01:49.000000000 +0100
@@ -419,6 +419,7 @@ ACPI_EXPORT_SYMBOL(acpi_enter_sleep_stat
  *              THIS FUNCTION MUST BE CALLED WITH INTERRUPTS DISABLED
  *
  ******************************************************************************/
+#ifndef CONFIG_XEN
 acpi_status asmlinkage acpi_enter_sleep_state_s4bios(void)
 {
 	u32 in_value;
@@ -472,6 +473,7 @@ acpi_status asmlinkage acpi_enter_sleep_
 }
 
 ACPI_EXPORT_SYMBOL(acpi_enter_sleep_state_s4bios)
+#endif
 
 /*******************************************************************************
  *
--- sle11sp3.orig/drivers/base/cpu.c	2012-11-12 10:17:32.000000000 +0100
+++ sle11sp3/drivers/base/cpu.c	2011-01-31 17:01:49.000000000 +0100
@@ -106,7 +106,7 @@ static inline void register_cpu_control(
 }
 #endif /* CONFIG_HOTPLUG_CPU */
 
-#ifdef CONFIG_KEXEC
+#if defined(CONFIG_KEXEC) && !defined(CONFIG_XEN)
 #include <linux/kexec.h>
 
 static ssize_t show_crash_notes(struct sys_device *dev, struct sysdev_attribute *attr,
@@ -231,7 +231,7 @@ int __cpuinit register_cpu(struct cpu *c
 	if (!error)
 		register_cpu_under_node(num, cpu_to_node(num));
 
-#ifdef CONFIG_KEXEC
+#if defined(CONFIG_KEXEC) && !defined(CONFIG_XEN)
 	if (!error)
 		error = sysdev_create_file(&cpu->sysdev, &attr_crash_notes);
 #endif
--- sle11sp3.orig/drivers/ide/ide-lib.c	2011-04-13 11:25:29.000000000 +0200
+++ sle11sp3/drivers/ide/ide-lib.c	2011-01-31 17:01:49.000000000 +0100
@@ -18,6 +18,16 @@ void ide_toggle_bounce(ide_drive_t *driv
 {
 	u64 addr = BLK_BOUNCE_HIGH;	/* dma64_addr_t */
 
+#ifndef CONFIG_XEN
+	if (!PCI_DMA_BUS_IS_PHYS) {
+		addr = BLK_BOUNCE_ANY;
+	} else if (on && drive->media == ide_disk) {
+		struct device *dev = drive->hwif->dev;
+
+		if (dev && dev->dma_mask)
+			addr = *dev->dma_mask;
+	}
+#else
 	if (on && drive->media == ide_disk) {
 		struct device *dev = drive->hwif->dev;
 
@@ -26,6 +36,7 @@ void ide_toggle_bounce(ide_drive_t *driv
 		else if (dev && dev->dma_mask)
 			addr = *dev->dma_mask;
 	}
+#endif
 
 	if (drive->queue)
 		blk_queue_bounce_limit(drive->queue, addr);
--- sle11sp3.orig/drivers/xen/console/console.c	2012-10-17 11:03:50.000000000 +0200
+++ sle11sp3/drivers/xen/console/console.c	2012-10-18 10:41:25.000000000 +0200
@@ -86,7 +86,6 @@ static int __init xencons_setup(char *st
 {
 	char *q;
 	int n;
-	extern int console_use_vt;
 
 	console_use_vt = 1;
 	if (!strncmp(str, "ttyS", 4)) {
--- sle11sp3.orig/drivers/xen/core/smpboot.c	2012-10-17 11:03:50.000000000 +0200
+++ sle11sp3/drivers/xen/core/smpboot.c	2012-10-18 10:41:17.000000000 +0200
@@ -53,7 +53,6 @@ static char callfunc_name[NR_CPUS][15];
 
 cpumask_t cpu_sibling_map[NR_CPUS] __cacheline_aligned;
 cpumask_t cpu_core_map[NR_CPUS] __cacheline_aligned;
-EXPORT_SYMBOL(cpu_core_map);
 
 #if defined(__i386__)
 u8 x86_cpu_to_apicid[NR_CPUS] = { [0 ... NR_CPUS-1] = 0xff };
--- sle11sp3.orig/include/linux/console.h	2012-11-12 10:17:32.000000000 +0100
+++ sle11sp3/include/linux/console.h	2011-01-31 14:30:58.000000000 +0100
@@ -73,6 +73,7 @@ extern const struct consw dummy_con;	/* 
 extern const struct consw vga_con;	/* VGA text console */
 extern const struct consw newport_con;	/* SGI Newport console  */
 extern const struct consw prom_con;	/* SPARC PROM console */
+extern int console_use_vt;
 
 int con_is_bound(const struct consw *csw);
 int register_con_driver(const struct consw *csw, int first, int last);
--- sle11sp3.orig/include/linux/page-flags.h	2012-11-12 10:23:48.000000000 +0100
+++ sle11sp3/include/linux/page-flags.h	2012-11-12 10:26:55.000000000 +0100
@@ -112,7 +112,7 @@ enum pageflags {
 #endif
 #ifdef CONFIG_XEN
 	PG_foreign,		/* Page is owned by foreign allocator. */
-	PG_netback,		/* Page is owned by netback */
+	/* PG_netback,		   Page is owned by netback */
 	PG_blkback,		/* Page is owned by blkback */
 #endif
 	__NR_PAGEFLAGS,
@@ -354,9 +354,11 @@ CLEARPAGEFLAG(Uptodate, uptodate)
 #define PageForeignDestructor(_page, order)		\
 	((void (*)(struct page *, unsigned int))(_page)->index)(_page, order)
 
+#if 0
 #define PageNetback(page)       test_bit(PG_netback, &(page)->flags)
 #define SetPageNetback(page)    set_bit(PG_netback, &(page)->flags)
 #define ClearPageNetback(page)  clear_bit(PG_netback, &(page)->flags)
+#endif
 
 #define PageBlkback(page)       test_bit(PG_blkback, &(page)->flags)
 #define SetPageBlkback(page)    set_bit(PG_blkback, &(page)->flags)
--- sle11sp3.orig/kernel/kexec.c	2012-11-12 10:26:00.000000000 +0100
+++ sle11sp3/kernel/kexec.c	2012-11-12 10:26:46.000000000 +0100
@@ -48,8 +48,10 @@
 #include <linux/lkdb.h>
 #endif
 
+#ifndef CONFIG_XEN
 /* Per cpu memory for storing cpu states in case of system crash. */
 note_buf_t __percpu *crash_notes;
+#endif
 int dump_after_notifier;
 
 /* vmcoreinfo stuff */
@@ -1264,6 +1266,7 @@ static void final_note(u32 *buf)
 	memcpy(buf, &note, sizeof(note));
 }
 
+#ifndef CONFIG_XEN
 void crash_save_cpu(struct pt_regs *regs, int cpu)
 {
 	struct elf_prstatus prstatus;
@@ -1289,6 +1292,7 @@ void crash_save_cpu(struct pt_regs *regs
 		      	      &prstatus, sizeof(prstatus));
 	final_note(buf);
 }
+#endif
 
 #ifdef CONFIG_SYSCTL
 static ctl_table dump_after_notifier_table[] = {
@@ -1314,6 +1318,7 @@ static ctl_table kexec_sys_table[] = {
 
 static int __init crash_notes_memory_init(void)
 {
+#ifndef CONFIG_XEN
 	/* Allocate memory for saving cpu registers. */
 	crash_notes = alloc_percpu(note_buf_t);
 	if (!crash_notes) {
@@ -1321,6 +1326,7 @@ static int __init crash_notes_memory_ini
 		" states failed\n");
 		return -ENOMEM;
 	}
+#endif
 #ifdef CONFIG_SYSCTL
 	register_sysctl_table(kexec_sys_table);
 #endif
--- sle11sp3.orig/mm/tmem-xen.c	2011-05-23 10:40:00.000000000 +0200
+++ sle11sp3/mm/tmem-xen.c	2011-05-23 11:03:08.000000000 +0200
@@ -7,8 +7,9 @@
 #include <linux/types.h>
 #include <xen/interface/xen.h>
 #include <asm/hypervisor.h>
+#include "tmem.h"
 
-int xen_tmem_op(u32 tmem_cmd, u32 tmem_pool, u64 object, u32 index,
+int xen_tmem_op(u32 tmem_cmd, u32 tmem_pool, struct tmem_oid oid, u32 index,
 	unsigned long gmfn, u32 tmem_offset, u32 pfn_offset, u32 len)
 {
 	struct tmem_op op;
@@ -16,8 +17,8 @@ int xen_tmem_op(u32 tmem_cmd, u32 tmem_p
 
 	op.cmd = tmem_cmd;
 	op.pool_id = tmem_pool;
-	op.u.gen.oid[0] = object;
-        op.u.gen.oid[1] = op.u.gen.oid[2] = 0;
+	BUILD_BUG_ON(sizeof(op.u.gen.oid) != sizeof(oid.oid));
+	memcpy(op.u.gen.oid, oid.oid, sizeof(op.u.gen.oid));
 	op.u.gen.index = index;
 	op.u.gen.tmem_offset = tmem_offset;
 	op.u.gen.pfn_offset = pfn_offset;
@@ -27,15 +28,28 @@ int xen_tmem_op(u32 tmem_cmd, u32 tmem_p
 	return rc;
 }
 
-int xen_tmem_new_pool(uint32_t tmem_cmd, uint64_t uuid_lo,
-	uint64_t uuid_hi, uint32_t flags)
+int xen_tmem_new_pool(uint32_t tmem_cmd, struct tmem_pool_uuid uuid,
+	uint32_t flags)
 {
 	struct tmem_op op;
 	int rc = 0;
 
 	op.cmd = tmem_cmd;
-	op.u.creat.uuid[0] = uuid_lo;
-	op.u.creat.uuid[1] = uuid_hi;
+	op.u.creat.uuid[0] = uuid.lo;
+	op.u.creat.uuid[1] = uuid.hi;
+#ifdef TMEM_SPEC_VERSION
+	switch (flags >> TMEM_POOL_VERSION_SHIFT) {
+	case 0:
+		flags |= TMEM_SPEC_VERSION << TMEM_POOL_VERSION_SHIFT;
+		break;
+	case TMEM_SPEC_VERSION:
+		break;
+	default:
+		WARN(1, "TMEM: Bogus version %u, expecting %u\n",
+		     flags >> TMEM_POOL_VERSION_SHIFT, TMEM_SPEC_VERSION);
+		return -ENOSYS;
+	}
+#endif
 	op.u.creat.flags = flags;
 	rc = HYPERVISOR_tmem_op(&op);
 	return rc;
