From: jbeulich@suse.com
Subject: allow non-pv-ops kernel to be built as bzImage
Patch-mainline: Never, SUSE-Xen specific
References: none

This, by enabling the EFI_STUB config option, is a prerequisite for
secure boot.

The XEN_ADVANCED_COMPRESSION part could be merged into the 2.6.30
patch (but is probably better kept here).

--- a/arch/x86/Kconfig
+++ b/arch/x86/Kconfig
@@ -1840,8 +1840,8 @@ config EFI
 
 config EFI_STUB
        bool "EFI stub support"
-       depends on EFI && !X86_USE_3DNOW && !XEN
-       select RELOCATABLE
+       depends on EFI && !X86_USE_3DNOW && (!XEN || XEN_BZIMAGE)
+       select RELOCATABLE if !XEN
        ---help---
           This kernel feature allows a bzImage to be loaded directly
 	  by EFI firmware without the use of a bootloader.
@@ -2118,6 +2118,23 @@ config RANDOMIZE_MEMORY_PHYSICAL_PADDING
 
 	   If unsure, leave at the default value.
 
+config XEN_BZIMAGE
+	bool "Produce bzImage (rather than ELF) format executable"
+	depends on XEN
+	depends on (XEN_UNPRIVILEGED_GUEST && (XEN_COMPAT >= 0x030402)) || (XEN_COMPAT >= 0x040000)
+	select HAVE_KERNEL_BZIP2 if XEN_ADVANCED_COMPRESSION
+	select HAVE_KERNEL_LZMA if XEN_ADVANCED_COMPRESSION
+	select HAVE_KERNEL_LZO if XEN_ADVANCED_COMPRESSION && (XEN_COMPAT > 0x040000)
+	select HAVE_KERNEL_XZ if XEN_ADVANCED_COMPRESSION && (XEN_COMPAT > 0x040104)
+	select HAVE_KERNEL_LZ4 if XEN_ADVANCED_COMPRESSION && (XEN_COMPAT >= 0x040400)
+	---help---
+	  Select whether, at the price of being incompatible with pre-3.4
+	  (pre-4.0 for Dom0) hypervisor versions, you want the final image
+	  to be in bzImage format, including the option to compress its
+	  embedded ELF image with methods better than gzip.
+	  Note that this is a prerequiste for building a kernel that can be
+	  used for secure boot from UEFI.
+
 config HOTPLUG_CPU
 	bool "Support for hot-pluggable CPUs"
 	depends on SMP
--- a/arch/x86/Makefile
+++ b/arch/x86/Makefile
@@ -244,7 +244,9 @@ LDFLAGS_vmlinux += -e startup_64
 else
 LDFLAGS_vmlinux += -e startup_32
 endif
+endif
 
+ifeq ($(CONFIG_XEN)-$(CONFIG_XEN_BZIMAGE),y-)
 # Default kernel to build
 all: vmlinuz
 
--- a/arch/x86/boot/Makefile
+++ b/arch/x86/boot/Makefile
@@ -45,6 +45,8 @@ setup-y		+= video-vga.o
 setup-y		+= video-vesa.o
 setup-y		+= video-bios.o
 
+setup-$(CONFIG_XEN) := header.o version.o
+
 targets		+= $(setup-y)
 hostprogs-y	:= tools/build
 hostprogs-$(CONFIG_X86_FEATURE_NAMES) += mkcpustr
@@ -196,7 +198,7 @@ $(obj)/vmlinux-stripped: OBJCOPYFLAGS :=
 $(obj)/vmlinux-stripped: vmlinux FORCE
 	$(call if_changed,objcopy)
 
-ifndef CONFIG_XEN
+ifneq ($(CONFIG_XEN)-$(CONFIG_XEN_BZIMAGE),y-)
 bzImage := bzImage
 else
 bzImage := vmlinuz
--- a/arch/x86/boot/boot.h
+++ b/arch/x86/boot/boot.h
@@ -23,7 +23,11 @@
 #include <stdarg.h>
 #include <linux/types.h>
 #include <linux/edd.h>
+#ifndef CONFIG_XEN
 #include <asm/setup.h>
+#else
+#include <asm/bootparam.h>
+#endif
 #include <asm/asm.h>
 #include "bitops.h"
 #include "ctype.h"
--- a/arch/x86/boot/compressed/Makefile
+++ b/arch/x86/boot/compressed/Makefile
@@ -41,6 +41,9 @@ GCOV_PROFILE := n
 UBSAN_SANITIZE :=n
 
 LDFLAGS := -m elf_$(UTS_MACHINE)
+ifeq ($(CONFIG_XEN),y)
+LDFLAGS += -e 0
+endif
 # Compressed kernel should be built as PIE since it may be loaded at any
 # address by the bootloader.
 ifeq ($(CONFIG_X86_32),y)
@@ -85,6 +88,11 @@ vmlinux-objs-$(CONFIG_EFI_STUB) += $(obj
 	$(objtree)/drivers/firmware/efi/libstub/lib.a
 vmlinux-objs-$(CONFIG_EFI_MIXED) += $(obj)/efi_thunk_$(BITS).o
 
+vmlinux-objs-$(CONFIG_XEN) := $(obj)/vmlinux.lds $(obj)/piggy.o
+
+# fake dependency to force voffset.h creation
+$(obj)/piggy.o: $(obj)/../voffset.h
+
 # The compressed kernel is built with -fPIC/-fPIE so that a boot loader
 # can place it anywhere in memory and it will still run. However, since
 # it is executed as-is without any ELF relocation processing performed
--- a/arch/x86/boot/header.S
+++ b/arch/x86/boot/header.S
@@ -522,6 +522,10 @@ pref_address:		.quad LOAD_PHYSICAL_ADDR
 #
 # extra_bytes = (uncompressed_size >> 12) + 65536 + 128
 
+#ifdef CONFIG_XEN
+#define ZO_startup_32 0
+#endif
+
 #define ZO_z_extra_bytes	((ZO_z_output_len >> 12) + 65536 + 128)
 #if ZO_z_output_len > ZO_z_input_len
 # define ZO_z_extract_offset	(ZO_z_output_len + ZO_z_extra_bytes - \
@@ -557,6 +561,7 @@ handover_offset:	.long 0			# Filled in b
 
 	.section ".entrytext", "ax"
 start_of_setup:
+#ifndef CONFIG_XEN
 # Force %es = %ds
 	movw	%ds, %ax
 	movw	%ax, %es
@@ -629,3 +634,4 @@ die:
 setup_corrupt:
 	.byte	7
 	.string	"No setup signature found...\n"
+#endif /* CONFIG_XEN */
--- a/arch/x86/boot/tools/build.c
+++ b/arch/x86/boot/tools/build.c
@@ -43,8 +43,10 @@ typedef unsigned int   u32;
 #define DEFAULT_MINOR_ROOT 0
 #define DEFAULT_ROOT_DEV (DEFAULT_MAJOR_ROOT << 8 | DEFAULT_MINOR_ROOT)
 
+#ifndef CONFIG_XEN
 /* Minimal number of setup sectors */
 #define SETUP_SECT_MIN 5
+#endif
 #define SETUP_SECT_MAX 64
 
 /* This must be large enough to hold the entire setup */
@@ -355,8 +357,8 @@ int main(int argc, char ** argv)
 	c = fread(buf, 1, sizeof(buf), file);
 	if (ferror(file))
 		die("read-error on `setup'");
-	if (c < 1024)
-		die("The setup must be at least 1024 bytes");
+	if (c <= 512)
+		die("The setup must be more than 512 bytes");
 	if (get_unaligned_le16(&buf[510]) != 0xAA55)
 		die("Boot block hasn't got boot flag (0xAA55)");
 	fclose(file);
@@ -365,8 +367,10 @@ int main(int argc, char ** argv)
 
 	/* Pad unused space with zeros */
 	setup_sectors = (c + 511) / 512;
+#ifdef SETUP_SECT_MIN
 	if (setup_sectors < SETUP_SECT_MIN)
 		setup_sectors = SETUP_SECT_MIN;
+#endif
 	i = setup_sectors*512;
 	memset(buf+c, 0, i-c);
 
--- a/drivers/firmware/efi/libstub/Makefile
+++ b/drivers/firmware/efi/libstub/Makefile
@@ -43,6 +43,8 @@ lib-$(CONFIG_ARM)		+= arm32-stub.o
 lib-$(CONFIG_ARM64)		+= arm64-stub.o
 CFLAGS_arm64-stub.o 		:= -DTEXT_OFFSET=$(TEXT_OFFSET)
 
+disabled-obj-$(CONFIG_XEN)	:= efi-stub-*.o
+
 #
 # arm64 puts the stub in the kernel proper, which will unnecessarily retain all
 # code indefinitely unless it is annotated as __init/__initdata/__initconst etc.
--- a/drivers/xen/Kconfig
+++ b/drivers/xen/Kconfig
@@ -366,6 +366,10 @@ config XEN_VCPU_INFO_PLACEMENT
 	  This allows faster access to the per-vCPU shared info
 	  structure.
 
+config XEN_ADVANCED_COMPRESSION
+	def_bool y
+	depends on XEN && (XEN_UNPRIVILEGED_GUEST || X86) && (XEN_COMPAT >= 0x040000)
+
 endmenu
 
 config HAVE_IRQ_IGNORE_UNHANDLED
