From: Michal Kubecek <mkubecek@suse.cz>
Date: Tue, 1 Dec 2015 15:44:03 +0100
Subject: kabi: protect struct unix_sock layout after epoll fix
Patch-mainline: Never, kabi workaround
References: bsc#917648 bsc#955654 CVE-2013-7446

The fix for bsc#917648 adds a wait_queue_t member into struct unix_sock.
We can't do that but fortunately there are unused members to store a
pointer to a separately allocated structure. We need a wrapper structure
with a pointer back to the socket as we can no longer use container_of()
to get it from the wait_queue_t. Destination and source IPv4 addresses
are used to store the pointer as these are not used for AF_UNIX sockets.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/af_unix.h | 33 ++++++++++++++++++++++++++++++++-
 net/unix/af_unix.c    | 32 ++++++++++++++++++++------------
 2 files changed, 52 insertions(+), 13 deletions(-)

diff --git a/include/net/af_unix.h b/include/net/af_unix.h
index 9ad39fa59d92..3d3d06f6679e 100644
--- a/include/net/af_unix.h
+++ b/include/net/af_unix.h
@@ -58,12 +58,43 @@ struct unix_sock {
 	unsigned int		gc_maybe_cycle : 1;
 	unsigned char		recursion_level;
 	struct socket_wq	peer_wq;
-	wait_queue_t		peer_wake;
 };
 #define unix_sk(__sk) ((struct unix_sock *)__sk)
 
 #define peer_wait peer_wq.wait
 
+struct unix_peer_wake {
+	wait_queue_t		wq;
+	struct unix_sock	*sk;
+};
+
+static inline wait_queue_t *get_peer_wake(struct unix_sock *usk)
+{
+	struct unix_peer_wake *pw;
+
+	pw = *((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr);
+	return &pw->wq;
+}
+
+static inline void set_peer_wake(struct unix_sock *usk,
+				 struct unix_peer_wake *pw)
+{
+	pw->sk = usk;
+	*((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr) = pw;
+}
+
+static inline struct unix_sock *get_peer_wake_sk(wait_queue_t *q)
+{
+	struct unix_peer_wake *pw = container_of(q, struct unix_peer_wake, wq);
+
+	return pw->sk;
+}
+
+static inline void unix_release_peer_wake(struct unix_sock *usk)
+{
+	kfree(*((struct unix_peer_wake **)&usk->sk.__sk_common.skc_daddr));
+}
+
 #ifdef CONFIG_SYSCTL
 extern int unix_sysctl_register(struct net *net);
 extern void unix_sysctl_unregister(struct net *net);
diff --git a/net/unix/af_unix.c b/net/unix/af_unix.c
index 107744cd7da6..d750917326ca 100644
--- a/net/unix/af_unix.c
+++ b/net/unix/af_unix.c
@@ -334,11 +334,11 @@ static int unix_dgram_peer_wake_relay(wait_queue_t *q, unsigned mode, int flags,
 	struct unix_sock *u;
 	wait_queue_head_t *u_sleep;
 
-	u = container_of(q, struct unix_sock, peer_wake);
+	u = get_peer_wake_sk(q);
 
-	__remove_wait_queue(&unix_sk(u->peer_wake.private)->peer_wait,
+	__remove_wait_queue(&unix_sk(get_peer_wake(u)->private)->peer_wait,
 			    q);
-	u->peer_wake.private = NULL;
+	get_peer_wake(u)->private = NULL;
 
 	/* relaying can only happen while the wq still exists */
 	u_sleep = sk_sleep(&u->sk);
@@ -358,9 +358,9 @@ static int unix_dgram_peer_wake_connect(struct sock *sk, struct sock *other)
 	rc = 0;
 	spin_lock(&u_other->peer_wait.lock);
 
-	if (!u->peer_wake.private) {
-		u->peer_wake.private = other;
-		__add_wait_queue(&u_other->peer_wait, &u->peer_wake);
+	if (!get_peer_wake(u)->private) {
+		get_peer_wake(u)->private = other;
+		__add_wait_queue(&u_other->peer_wait, get_peer_wake(u));
 
 		rc = 1;
 	}
@@ -378,9 +378,9 @@ static void unix_dgram_peer_wake_disconnect(struct sock *sk,
 	u_other = unix_sk(other);
 	spin_lock(&u_other->peer_wait.lock);
 
-	if (u->peer_wake.private == other) {
-		__remove_wait_queue(&u_other->peer_wait, &u->peer_wake);
-		u->peer_wake.private = NULL;
+	if (get_peer_wake(u)->private == other) {
+		__remove_wait_queue(&u_other->peer_wait, get_peer_wake(u));
+		get_peer_wake(u)->private = NULL;
 	}
 
 	spin_unlock(&u_other->peer_wait.lock);
@@ -472,6 +472,7 @@ static void unix_sock_destructor(struct sock *sk)
 
 	if (u->addr)
 		unix_release_addr(u->addr);
+	unix_release_peer_wake(u);
 
 	atomic_long_dec(&unix_nr_socks);
 	local_bh_disable();
@@ -720,6 +721,11 @@ static struct sock *unix_create1(struct net *net, struct socket *sock)
 {
 	struct sock *sk = NULL;
 	struct unix_sock *u;
+	struct unix_peer_wake *pw;
+
+	pw = kmalloc(sizeof(*pw), GFP_KERNEL);
+	if (!pw)
+		return NULL;
 
 	atomic_long_inc(&unix_nr_socks);
 	if (atomic_long_read(&unix_nr_socks) > 2 * get_max_files())
@@ -744,12 +750,14 @@ static struct sock *unix_create1(struct net *net, struct socket *sock)
 	INIT_LIST_HEAD(&u->link);
 	mutex_init(&u->readlock); /* single task reading lock */
 	init_waitqueue_head(&u->peer_wait);
-	init_waitqueue_func_entry(&u->peer_wake, unix_dgram_peer_wake_relay);
+	set_peer_wake(u, pw);
+	init_waitqueue_func_entry(get_peer_wake(u), unix_dgram_peer_wake_relay);
 	unix_insert_socket(unix_sockets_unbound, sk);
 out:
-	if (sk == NULL)
+	if (sk == NULL) {
 		atomic_long_dec(&unix_nr_socks);
-	else {
+		kfree(pw);
+	} else {
 		local_bh_disable();
 		sock_prot_inuse_add(sock_net(sk), sk->sk_prot, 1);
 		local_bh_enable();
-- 
2.7.0

