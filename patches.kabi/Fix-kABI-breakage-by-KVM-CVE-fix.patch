From: Joerg Roedel <jroedel@suse.de>
Subject: Fix kABI breakage by KVM CVE fix
Patch-mainline: Never, kabi
References: bsc#1045922

The patch
  patches.kernel.org/4.4.100-004-KVM-x86-fix-singlestepping-over-syscall.patch
breaks kABI due to the introduction of tf to the emulation
context field.
This patch moves the new bool flag to the existing
regs_valid member to avoid the new member and preserve kabi.

Signed-off-by: Joerg Roedel <jroedel@suse.de>
---
 arch/x86/include/asm/kvm_emulate.h |  1 -
 arch/x86/include/asm/kvm_host.h    |  2 ++
 arch/x86/kvm/emulate.c             |  6 +++++-
 arch/x86/kvm/x86.c                 | 11 +++++++++--
 4 files changed, 16 insertions(+), 4 deletions(-)

diff --git a/arch/x86/include/asm/kvm_emulate.h b/arch/x86/include/asm/kvm_emulate.h
index 4a3f54f..e9cd7be 100644
--- a/arch/x86/include/asm/kvm_emulate.h
+++ b/arch/x86/include/asm/kvm_emulate.h
@@ -294,7 +294,6 @@ struct x86_emulate_ctxt {
 
 	bool perm_ok; /* do not check permissions if true */
 	bool ud;	/* inject an #UD if host doesn't support insn */
-	bool tf;	/* TF value before instruction (after for syscall/sysret) */
 
 	bool have_exception;
 	struct x86_exception exception;
diff --git a/arch/x86/include/asm/kvm_host.h b/arch/x86/include/asm/kvm_host.h
index fefd8b1..4447f6e 100644
--- a/arch/x86/include/asm/kvm_host.h
+++ b/arch/x86/include/asm/kvm_host.h
@@ -118,6 +118,8 @@ enum kvm_reg {
 	NR_VCPU_REGS
 };
 
+#define VCPU_REGS_TF	31 /* TF value before instruction (after for syscall/sysret) */
+
 enum kvm_reg_ex {
 	VCPU_EXREG_PDPTR = NR_VCPU_REGS,
 	VCPU_EXREG_CR3,
diff --git a/arch/x86/kvm/emulate.c b/arch/x86/kvm/emulate.c
index 15e3ddd..c3e94f7 100644
--- a/arch/x86/kvm/emulate.c
+++ b/arch/x86/kvm/emulate.c
@@ -2726,7 +2726,11 @@ static int em_syscall(struct x86_emulate_ctxt *ctxt)
 		ctxt->eflags &= ~(X86_EFLAGS_VM | X86_EFLAGS_IF);
 	}
 
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
+	if (ctxt->eflags & X86_EFLAGS_TF)
+		ctxt->regs_valid |= (1U << VCPU_REGS_TF);
+	else
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
+
 	return X86EMUL_CONTINUE;
 }
 
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index d092630..994db26 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5086,7 +5086,11 @@ static void init_emulate_ctxt(struct kvm_vcpu *vcpu)
 	kvm_x86_ops->get_cs_db_l_bits(vcpu, &cs_db, &cs_l);
 
 	ctxt->eflags = kvm_get_rflags(vcpu);
-	ctxt->tf = (ctxt->eflags & X86_EFLAGS_TF) != 0;
+	if (ctxt->eflags & X86_EFLAGS_TF)
+		ctxt->regs_valid |= (1U << VCPU_REGS_TF);
+	else
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
+
 
 	ctxt->eip = kvm_rip_read(vcpu);
 	ctxt->mode = (!is_protmode(vcpu))		? X86EMUL_MODE_REAL :
@@ -5479,13 +5483,16 @@ restart:
 
 	if (writeback) {
 		unsigned long rflags = kvm_x86_ops->get_rflags(vcpu);
+		bool tf = ((ctxt->regs_valid & (1U << VCPU_REGS_TF)) != 0);
+
+		ctxt->regs_valid &= ~(1U << VCPU_REGS_TF);
 		toggle_interruptibility(vcpu, ctxt->interruptibility);
 		vcpu->arch.emulate_regs_need_sync_to_vcpu = false;
 		if (vcpu->arch.hflags != ctxt->emul_flags)
 			kvm_set_hflags(vcpu, ctxt->emul_flags);
 		kvm_rip_write(vcpu, ctxt->eip);
 		if (r == EMULATE_DONE &&
-		    (ctxt->tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))
+		    (tf || (vcpu->guest_debug & KVM_GUESTDBG_SINGLESTEP)))
 			kvm_vcpu_do_singlestep(vcpu, &r);
 		if (!ctxt->have_exception ||
 		    exception_type(ctxt->exception.vector) == EXCPT_TRAP)
-- 
1.8.5.6

