From: Michal Kubecek <mkubecek@suse.cz>
Date: Wed, 9 Mar 2016 09:44:27 +0100
Subject: kabi: protect struct netns_ipv6 after FIB6 GC series
Patch-mainline: Never, kabi workaround
References: bsc#965319

Backports of patches

  812918c464ec ("ipv6: make fib6 serial number per namespace")
  9a03cd8f38ef ("ipv6: per netns fib6 walkers")
  3dc94f93be16 ("ipv6: per netns FIB garbage collection")

add new members into struct netns_ipv6 which would break kABI as this
structure is embedded in struct net. Moving these new members to the end
of struct net and hiding them from genksyms should be safe as instances
of struct net should always be created using net_alloc() - or rather
copy_net_ns() as the former is static.

Using net_generic infrastructure would be cleaner but it would add some
overhead and resulting code would be less readable.

Signed-off-by: Michal Kubecek <mkubecek@suse.cz>
---
 include/net/net_namespace.h |  6 ++++++
 include/net/netns/ipv6.h    |  4 ----
 net/ipv6/ip6_fib.c          | 38 +++++++++++++++++++-------------------
 3 files changed, 25 insertions(+), 23 deletions(-)

diff --git a/include/net/net_namespace.h b/include/net/net_namespace.h
index a298d10d3d20..d7d02b85d77a 100644
--- a/include/net/net_namespace.h
+++ b/include/net/net_namespace.h
@@ -103,6 +103,12 @@ struct net {
 	struct netns_xfrm	xfrm;
 #endif
 	struct netns_ipvs	*ipvs;
+#ifndef __GENKSYMS__
+	struct list_head	fib6_walkers;
+	rwlock_t		fib6_walker_lock;
+	spinlock_t		fib6_gc_lock;
+	__u32			fib6_sernum;
+#endif
 };
 
 
diff --git a/include/net/netns/ipv6.h b/include/net/netns/ipv6.h
index 86fb2f57ecfd..aeea97f6b7e1 100644
--- a/include/net/netns/ipv6.h
+++ b/include/net/netns/ipv6.h
@@ -47,12 +47,8 @@ struct netns_ipv6 {
 	struct timer_list       ip6_fib_timer;
 	struct hlist_head       *fib_table_hash;
 	struct fib6_table       *fib6_main_tbl;
-	struct list_head	fib6_walkers;
 	struct dst_ops		ip6_dst_ops;
-	rwlock_t		fib6_walker_lock;
-	spinlock_t		fib6_gc_lock;
 	unsigned int		 ip6_rt_gc_expire;
-	__u32			fib6_sernum;
 	unsigned long		 ip6_rt_last_gc;
 #ifdef CONFIG_IPV6_MULTIPLE_TABLES
 	struct rt6_info         *ip6_prohibit_entry;
diff --git a/net/ipv6/ip6_fib.c b/net/ipv6/ip6_fib.c
index 01e1fd3bef1b..5b00ebda8cbd 100644
--- a/net/ipv6/ip6_fib.c
+++ b/net/ipv6/ip6_fib.c
@@ -92,26 +92,26 @@ static int fib6_walk_continue(struct fib6_walker_t *w);
 static void fib6_gc_timer_cb(unsigned long arg);
 
 #define FOR_WALKERS(net, w) \
-	list_for_each_entry(w, &(net)->ipv6.fib6_walkers, lh)
+	list_for_each_entry(w, &(net)->fib6_walkers, lh)
 
 static inline void fib6_walker_link(struct net *net, struct fib6_walker_t *w)
 {
-	write_lock_bh(&net->ipv6.fib6_walker_lock);
-	list_add(&w->lh, &net->ipv6.fib6_walkers);
-	write_unlock_bh(&net->ipv6.fib6_walker_lock);
+	write_lock_bh(&net->fib6_walker_lock);
+	list_add(&w->lh, &net->fib6_walkers);
+	write_unlock_bh(&net->fib6_walker_lock);
 }
 
 static inline void fib6_walker_unlink(struct net *net, struct fib6_walker_t *w)
 {
-	write_lock_bh(&net->ipv6.fib6_walker_lock);
+	write_lock_bh(&net->fib6_walker_lock);
 	list_del(&w->lh);
-	write_unlock_bh(&net->ipv6.fib6_walker_lock);
+	write_unlock_bh(&net->fib6_walker_lock);
 }
 static __inline__ u32 fib6_new_sernum(struct net *net)
 {
-	u32 n = ++(net->ipv6.fib6_sernum);
+	u32 n = ++(net->fib6_sernum);
 	if ((__s32)n <= 0)
-		net->ipv6.fib6_sernum = n = 1;
+		net->fib6_sernum = n = 1;
 	return n;
 }
 
@@ -1166,7 +1166,7 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 		}
 #endif
 
-		read_lock(&net->ipv6.fib6_walker_lock);
+		read_lock(&net->fib6_walker_lock);
 		FOR_WALKERS(net, w) {
 			if (child == NULL) {
 				if (w->root == fn) {
@@ -1194,7 +1194,7 @@ static struct fib6_node *fib6_repair_tree(struct net *net,
 				}
 			}
 		}
-		read_unlock(&net->ipv6.fib6_walker_lock);
+		read_unlock(&net->fib6_walker_lock);
 
 		node_free(fn);
 		if (pn->fn_flags&RTN_RTINFO || FIB6_SUBTREE(pn))
@@ -1226,7 +1226,7 @@ static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,
 		fn->rr_ptr = NULL;
 
 	/* Adjust walkers */
-	read_lock(&net->ipv6.fib6_walker_lock);
+	read_lock(&net->fib6_walker_lock);
 	FOR_WALKERS(net, w) {
 		if (w->state == FWS_C && w->leaf == rt) {
 			RT6_TRACE("walker %p adjusted by delroute\n", w);
@@ -1235,7 +1235,7 @@ static void fib6_del_route(struct fib6_node *fn, struct rt6_info **rtp,
 				w->state = FWS_U;
 		}
 	}
-	read_unlock(&net->ipv6.fib6_walker_lock);
+	read_unlock(&net->fib6_walker_lock);
 
 	rt->dst.rt6_next = NULL;
 
@@ -1579,8 +1579,8 @@ void fib6_run_gc(unsigned long expires, struct net *net, bool force)
 	unsigned long now;
 
 	if (force) {
-		spin_lock_bh(&net->ipv6.fib6_gc_lock);
-	} else if (!spin_trylock_bh(&net->ipv6.fib6_gc_lock)) {
+		spin_lock_bh(&net->fib6_gc_lock);
+	} else if (!spin_trylock_bh(&net->fib6_gc_lock)) {
 		mod_timer(&net->ipv6.ip6_fib_timer, jiffies + HZ);
 		return;
 	}
@@ -1599,7 +1599,7 @@ void fib6_run_gc(unsigned long expires, struct net *net, bool force)
 					+ net->ipv6.sysctl.ip6_rt_gc_interval));
 	else
 		del_timer(&net->ipv6.ip6_fib_timer);
-	spin_unlock_bh(&net->ipv6.fib6_gc_lock);
+	spin_unlock_bh(&net->fib6_gc_lock);
 }
 
 static void fib6_gc_timer_cb(unsigned long arg)
@@ -1611,10 +1611,10 @@ static int __net_init fib6_net_init(struct net *net)
 {
 	size_t size = sizeof(struct hlist_head) * FIB6_TABLE_HASHSZ;
 
-	net->ipv6.fib6_sernum = 1;
-	spin_lock_init(&net->ipv6.fib6_gc_lock);
-	rwlock_init(&net->ipv6.fib6_walker_lock);
-	INIT_LIST_HEAD(&net->ipv6.fib6_walkers);
+	net->fib6_sernum = 1;
+	spin_lock_init(&net->fib6_gc_lock);
+	rwlock_init(&net->fib6_walker_lock);
+	INIT_LIST_HEAD(&net->fib6_walkers);
 	setup_timer(&net->ipv6.ip6_fib_timer, fib6_gc_timer_cb, (unsigned long)net);
 
 	net->ipv6.rt6_stats = kzalloc(sizeof(*net->ipv6.rt6_stats), GFP_KERNEL);
-- 
2.8.1

