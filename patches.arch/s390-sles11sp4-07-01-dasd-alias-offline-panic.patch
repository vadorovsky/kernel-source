From: Stefan Haberland <stefan.haberland@de.ibm.com>
Subject: s390/dasd: fix kernel panic when alias is set offline
Patch-mainline: v4.2-rc3
Git-commit: f81a49d13b3014c2b7c424628779a8af93f25c04
References: bnc#940966, LTC#128595

Description:  s390/dasd: fix kernel panic when alias is set offline
Symptom:      Kernel panic or device hang when an alias device is set
              offline.
Problem:      The dasd device driver selects which (alias or base)
              device is used for a given requests when the request is
              build. If the chosen alias device is set offline before
              the request gets queued to the device queue the starting
              function may use device structures that are already
              freed. This might lead to a hanging offline process or a
              kernel panic.
Solution:     Add a check to the starting function that returns the
              request to the upper layer if the device is already in
              offline processing.
              In addition to that prevent that an alias device that's
              already in offline processing gets chosen as start
              device.
Reproduction: Have a dasd base device with a set of alias devices in 
              use and set one or more alias devices offline.

Upstream-Description:

              s390/dasd: fix kernel panic when alias is set offline

              The dasd device driver selects which (alias or base) device is used
              for a given requests when the request is build. If the chosen alias
              device is set offline before the request gets queued to the device
              queue the starting function may use device structures that are
              already freed. This might lead to a hanging offline process or a
              kernel panic.

              Add a check to the starting function that returns the request to the
              upper layer if the device is already in offline processing.

              In addition to that prevent that an alias device that's already in
              offline processing gets chosen as start device.

              Reviewed-by: Sebastian Ott <sebott@linux.vnet.ibm.com>
              Reviewed-by: Peter Oberparleiter <peter.oberparleiter@linux.vnet.ibm.com>
              Signed-off-by: Stefan Haberland <stefan.haberland@de.ibm.com>
              Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>


Signed-off-by: Stefan Haberland <stefan.haberland@de.ibm.com>
Acked-by: John Jolly <jjolly@suse.de>
---
 drivers/s390/block/dasd.c       |   31 ++++++++++++++++++++++++-------
 drivers/s390/block/dasd_alias.c |    3 ++-
 2 files changed, 26 insertions(+), 8 deletions(-)

--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -1881,6 +1881,28 @@ static void __dasd_device_check_expire(s
 }
 
 /*
+ * return 1 when device is not eligible for IO because it is
+ * - set offline (DASD_FLAG_OFFLINE)
+ * - stopped (device->stopped)
+ *
+ * exception:
+ * The device is stopped but the request is needed to get it
+ * operational again.
+ * So the CQR is a path verification request (DASD_CQR_VERIFY_PATH)
+ * and only the disconnected or unresumed stop bit is set
+ * (DASD_STOPPED_DC_WAIT | DASD_UNRESUMED_PM)
+ */
+static int __dasd_device_is_unusable(struct dasd_device *device,
+				     struct dasd_ccw_req *cqr)
+{
+	return test_bit(DASD_FLAG_OFFLINE, &device->flags) ||
+		(device->stopped &&
+		 !(!(device->stopped &
+		     ~(DASD_STOPPED_DC_WAIT | DASD_UNRESUMED_PM)) &&
+		   test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags)));
+}
+
+/*
  * Take a look at the first request on the ccw queue and check
  * if it needs to be started.
  */
@@ -1894,13 +1916,8 @@ static void __dasd_device_start_head(str
 	cqr = list_entry(device->ccw_queue.next, struct dasd_ccw_req, devlist);
 	if (cqr->status != DASD_CQR_QUEUED)
 		return;
-	/* when device is stopped, return request to previous layer
-	 * exception: only the disconnect or unresumed bits are set and the
-	 * cqr is a path verification request
-	 */
-	if (device->stopped &&
-	    !(!(device->stopped & ~(DASD_STOPPED_DC_WAIT | DASD_UNRESUMED_PM))
-	      && test_bit(DASD_CQR_VERIFY_PATH, &cqr->flags))) {
+	/* if device is not usable return request to upper layer */
+	if (__dasd_device_is_unusable(device, cqr)) {
 		cqr->intrc = -EAGAIN;
 		cqr->status = DASD_CQR_CLEARED;
 		dasd_schedule_device_bh(device);
--- a/drivers/s390/block/dasd_alias.c
+++ b/drivers/s390/block/dasd_alias.c
@@ -674,7 +674,8 @@ struct dasd_device *dasd_alias_get_start
 					       struct dasd_device, alias_list);
 	spin_unlock_irqrestore(&lcu->lock, flags);
 	alias_priv = (struct dasd_eckd_private *) alias_device->private;
-	if ((alias_priv->count < private->count) && !alias_device->stopped)
+	if ((alias_priv->count < private->count) && !alias_device->stopped &&
+	    !test_bit(DASD_FLAG_OFFLINE, &alias_device->flags))
 		return alias_device;
 	else
 		return NULL;
