From: Marc Zyngier <marc.zyngier@arm.com>
Date: Fri, 22 Apr 2016 12:25:33 +0100
Subject: irqchip/gic: Restore CPU interface checking
Git-commit: 25fc11aead380501d70b701e136e89d321277177
Patch-mainline: v4.7-rc1
References: fate#322150

When introducing the whole CPU feature detection framework,
we lost the capability to detect a mismatched GIC configuration
(using the GICv2 MMIO interface, but having the system register
interface enabled).

In order to solve this, use the new this_cpu_has_cap() helper.
Also move the check to the CPU interface path in order to catch
systems where the first CPU has been correctly configured,
but the secondaries are not.

Reviewed-by: Catalin Marinas <catalin.marinas@arm.com>
Signed-off-by: Marc Zyngier <marc.zyngier@arm.com>
Signed-off-by: Suzuki K Poulose <suzuki.poulose@arm.com>
Signed-off-by: Will Deacon <will.deacon@arm.com>
Signed-off-by: Matthias Brugger <mbrugger@suse.com>
---
 drivers/irqchip/irq-gic.c |    5 ++---
 1 file changed, 2 insertions(+), 3 deletions(-)

--- a/drivers/irqchip/irq-gic.c
+++ b/drivers/irqchip/irq-gic.c
@@ -55,7 +55,7 @@
 
 static void gic_check_cpu_features(void)
 {
-	WARN_TAINT_ONCE(cpus_have_cap(ARM64_HAS_SYSREG_GIC_CPUIF),
+	WARN_TAINT_ONCE(this_cpu_has_cap(ARM64_HAS_SYSREG_GIC_CPUIF),
 			TAINT_CPU_OUT_OF_SPEC,
 			"GICv3 system registers enabled, broken firmware!\n");
 }
@@ -509,6 +509,7 @@ static int gic_cpu_init(struct gic_chip_
 		if (WARN_ON(cpu >= NR_GIC_CPU_IF))
 			return -EINVAL;
 
+		gic_check_cpu_features();
 		cpu_mask = gic_get_cpumask(gic);
 		gic_cpu_map[cpu] = cpu_mask;
 
@@ -1059,8 +1060,6 @@ static const struct irq_domain_ops gic_i
 static void gic_init_chip(struct gic_chip_data *gic, struct device *dev,
 			 const char *name, bool use_eoimode1)
 {
-	gic_check_cpu_features();
-
 	/* Initialize irq_chip */
 	gic->chip = gic_chip;
 	gic->chip.name = name;
