From a8211e5eec80763a378f7bd0f019e1fa8b528ce5 Mon Sep 17 00:00:00 2001
From: Nicholas Piggin <npiggin@gmail.com>
Date: Wed, 30 May 2018 20:31:22 +1000
Subject: [PATCH 1/6] powerpc/64s: Fix compiler store ordering to SLB shadow
 area

References: bsc#1094244
Patch-mainline: v4.18-rc1
Git-commit: 926bc2f100c24d4842b3064b5af44ae964c1d81c

The stores to update the SLB shadow area must be made as they appear
in the C code, so that the hypervisor does not see an entry with
mismatched vsid and esid. Use WRITE_ONCE for this.

GCC has been observed to elide the first store to esid in the update,
which means that if the hypervisor interrupts the guest after storing
to vsid, it could see an entry with old esid and new vsid, which may
possibly result in memory corruption.

Signed-off-by: Nicholas Piggin <npiggin@gmail.com>
Signed-off-by: Michael Ellerman <mpe@ellerman.id.au>
[use ACCESS_ONCE in place of the new WRITE_ONCE]
Signed-off-by: Laurent Dufour <ldufour@linux.vnet.ibm.com>
Acked-by: Michal Suchanek <msuchanek@suse.de>
---
 arch/powerpc/mm/slb.c | 10 ++++++----
 1 file changed, 6 insertions(+), 4 deletions(-)

diff --git a/arch/powerpc/mm/slb.c b/arch/powerpc/mm/slb.c
index e22276cb67a4..0b914e8e3e83 100644
--- a/arch/powerpc/mm/slb.c
+++ b/arch/powerpc/mm/slb.c
@@ -61,19 +61,21 @@ static inline void slb_shadow_update(unsigned long ea, int ssize,
 				     unsigned long flags,
 				     unsigned long entry)
 {
+	struct slb_shadow *p = get_slb_shadow();
+
 	/*
 	 * Clear the ESID first so the entry is not valid while we are
 	 * updating it.  No write barriers are needed here, provided
 	 * we only update the current CPU's SLB shadow buffer.
 	 */
-	get_slb_shadow()->save_area[entry].esid = 0;
-	get_slb_shadow()->save_area[entry].vsid = mk_vsid_data(ea, ssize, flags);
-	get_slb_shadow()->save_area[entry].esid = mk_esid_data(ea, ssize, entry);
+	ACCESS_ONCE(p->save_area[entry].esid) = 0;
+	ACCESS_ONCE(p->save_area[entry].vsid) = mk_vsid_data(ea, ssize, flags);
+	ACCESS_ONCE(p->save_area[entry].esid) = mk_esid_data(ea, ssize, entry);
 }
 
 static inline void slb_shadow_clear(unsigned long entry)
 {
-	get_slb_shadow()->save_area[entry].esid = 0;
+	ACCESS_ONCE(get_slb_shadow()->save_area[entry].esid) = 0;
 }
 
 static inline void create_shadowed_slbe(unsigned long ea, int ssize,
-- 
2.7.4

