From: He Chen <he.chen@linux.intel.com>
Date: Fri, 11 Nov 2016 17:25:35 +0800
Subject: x86/cpuid: Provide get_scattered_cpuid_leaf()
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit
Patch-mainline: v4.10-rc1
Git-commit: 47bdf3378d62a627cfb8a54e1180c08d67078b61
References: FATE#323110

Sparse populated CPUID leafs are collected in a software provided leaf to
avoid bloat of the x86_capability array, but there is no way to rebuild the
real leafs (e.g. for KVM CPUID enumeration) other than rereading the CPUID
leaf from the CPU. While this is possible it is problematic as it does not
take software disabled features into account. If a feature is disabled on
the host it should not be exposed to a guest either.

Add get_scattered_cpuid_leaf() which rebuilds the leaf from the scattered
cpuid table information and the active CPU features.

[ tglx: Rewrote changelog ]

Signed-off-by: He Chen <he.chen@linux.intel.com>
Reviewed-by: Borislav Petkov <bp@suse.de>
Cc: Luwei Kang <luwei.kang@intel.com>
Cc: kvm@vger.kernel.org
Cc: Radim Krčmář <rkrcmar@redhat.com>
Cc: Piotr Luc <Piotr.Luc@intel.com>
Cc: Borislav Petkov <bp@alien8.de>
Cc: Paolo Bonzini <pbonzini@redhat.com>
Link: http://lkml.kernel.org/r/1478856336-9388-3-git-send-email-he.chen@linux.intel.com
Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

Signed-off-by: Bruce Rogers <brogers@suse.com>
---
 arch/x86/include/asm/processor.h |    3 +
 arch/x86/kernel/cpu/scattered.c  |   99 ++++++++++++++++++++++++---------------
 2 files changed, 65 insertions(+), 37 deletions(-)

--- a/arch/x86/include/asm/processor.h
+++ b/arch/x86/include/asm/processor.h
@@ -193,6 +193,9 @@ extern void identify_secondary_cpu(struc
 extern void print_cpu_info(struct cpuinfo_x86 *);
 void print_cpu_msr(struct cpuinfo_x86 *);
 extern void init_scattered_cpuid_features(struct cpuinfo_x86 *c);
+extern u32 get_scattered_cpuid_leaf(unsigned int level,
+				    unsigned int sub_leaf,
+				    enum cpuid_regs_idx reg);
 extern unsigned int init_intel_cacheinfo(struct cpuinfo_x86 *c);
 extern void init_amd_cacheinfo(struct cpuinfo_x86 *c);
 
--- a/arch/x86/kernel/cpu/scattered.c
+++ b/arch/x86/kernel/cpu/scattered.c
@@ -17,50 +17,51 @@ struct cpuid_bit {
 	u32 sub_leaf;
 };
 
+/* Please keep the leaf sorted by cpuid_bit.level for faster search. */
+static const struct cpuid_bit cpuid_bits[] = {
+	{ X86_FEATURE_DTHERM,		CPUID_EAX, 0, 0x00000006, 0 },
+	{ X86_FEATURE_IDA,		CPUID_EAX, 1, 0x00000006, 0 },
+	{ X86_FEATURE_ARAT,		CPUID_EAX, 2, 0x00000006, 0 },
+	{ X86_FEATURE_PLN,		CPUID_EAX, 4, 0x00000006, 0 },
+	{ X86_FEATURE_PTS,		CPUID_EAX, 6, 0x00000006, 0 },
+	{ X86_FEATURE_HWP,		CPUID_EAX, 7, 0x00000006, 0 },
+	{ X86_FEATURE_HWP_NOTIFY,	CPUID_EAX, 8, 0x00000006, 0 },
+	{ X86_FEATURE_HWP_ACT_WINDOW,	CPUID_EAX, 9, 0x00000006, 0 },
+	{ X86_FEATURE_HWP_EPP,		CPUID_EAX,10, 0x00000006, 0 },
+	{ X86_FEATURE_HWP_PKG_REQ,	CPUID_EAX,11, 0x00000006, 0 },
+	{ X86_FEATURE_APERFMPERF,	CPUID_ECX, 0, 0x00000006, 0 },
+	{ X86_FEATURE_EPB,		CPUID_ECX, 3, 0x00000006, 0 },
+	{ X86_FEATURE_INTEL_PT,		CPUID_EBX,25, 0x00000007, 0 },
+	{ X86_FEATURE_AVX512_4VNNIW,	CPUID_EDX, 2, 0x00000007, 0 },
+	{ X86_FEATURE_AVX512_4FMAPS,	CPUID_EDX, 3, 0x00000007, 0 },
+	{ X86_FEATURE_SPEC_CTRL,	CPUID_EDX,26, 0x00000007, 0 },
+	{ X86_FEATURE_INTEL_STIBP,	CPUID_EDX,27, 0x00000007, 0 },
+	{ X86_FEATURE_FLUSH_L1D,	CPUID_EDX,28, 0x00000007, 0 },
+	{ X86_FEATURE_ARCH_CAPABILITIES, CPUID_EDX,29, 0x00000007, 0 },
+	{ X86_FEATURE_SPEC_CTRL_SSBD,	CPUID_EDX,31, 0x00000007, 0 },
+	{ X86_FEATURE_HW_PSTATE,	CPUID_EDX, 7, 0x80000007, 0 },
+	{ X86_FEATURE_CPB,		CPUID_EDX, 9, 0x80000007, 0 },
+	{ X86_FEATURE_PROC_FEEDBACK,	CPUID_EDX,11, 0x80000007, 0 },
+	{ X86_FEATURE_NPT,		CPUID_EDX, 0, 0x8000000a, 0 },
+	{ X86_FEATURE_LBRV,		CPUID_EDX, 1, 0x8000000a, 0 },
+	{ X86_FEATURE_SVML,		CPUID_EDX, 2, 0x8000000a, 0 },
+	{ X86_FEATURE_NRIPS,		CPUID_EDX, 3, 0x8000000a, 0 },
+	{ X86_FEATURE_TSCRATEMSR,	CPUID_EDX, 4, 0x8000000a, 0 },
+	{ X86_FEATURE_VMCBCLEAN,	CPUID_EDX, 5, 0x8000000a, 0 },
+	{ X86_FEATURE_FLUSHBYASID,	CPUID_EDX, 6, 0x8000000a, 0 },
+	{ X86_FEATURE_DECODEASSISTS,	CPUID_EDX, 7, 0x8000000a, 0 },
+	{ X86_FEATURE_PAUSEFILTER,	CPUID_EDX,10, 0x8000000a, 0 },
+	{ X86_FEATURE_PFTHRESHOLD,	CPUID_EDX,12, 0x8000000a, 0 },
+	{ X86_FEATURE_AVIC,		CPUID_EDX,13, 0x8000000a, 0 },
+	{ 0, 0, 0, 0, 0 }
+};
+
 void init_scattered_cpuid_features(struct cpuinfo_x86 *c)
 {
 	u32 max_level;
 	u32 regs[4];
 	const struct cpuid_bit *cb;
 
-	static const struct cpuid_bit cpuid_bits[] = {
-		{ X86_FEATURE_DTHERM,		CPUID_EAX, 0, 0x00000006, 0 },
-		{ X86_FEATURE_IDA,		CPUID_EAX, 1, 0x00000006, 0 },
-		{ X86_FEATURE_ARAT,		CPUID_EAX, 2, 0x00000006, 0 },
-		{ X86_FEATURE_PLN,		CPUID_EAX, 4, 0x00000006, 0 },
-		{ X86_FEATURE_PTS,		CPUID_EAX, 6, 0x00000006, 0 },
-		{ X86_FEATURE_HWP,		CPUID_EAX, 7, 0x00000006, 0 },
-		{ X86_FEATURE_HWP_NOTIFY,	CPUID_EAX, 8, 0x00000006, 0 },
-		{ X86_FEATURE_HWP_ACT_WINDOW,	CPUID_EAX, 9, 0x00000006, 0 },
-		{ X86_FEATURE_HWP_EPP,		CPUID_EAX,10, 0x00000006, 0 },
-		{ X86_FEATURE_HWP_PKG_REQ,	CPUID_EAX,11, 0x00000006, 0 },
-		{ X86_FEATURE_INTEL_PT,		CPUID_EBX,25, 0x00000007, 0 },
-		{ X86_FEATURE_AVX512_4VNNIW,	CPUID_EDX, 2, 0x00000007, 0 },
-		{ X86_FEATURE_AVX512_4FMAPS,	CPUID_EDX, 3, 0x00000007, 0 },
-		{ X86_FEATURE_APERFMPERF,	CPUID_ECX, 0, 0x00000006, 0 },
-		{ X86_FEATURE_EPB,		CPUID_ECX, 3, 0x00000006, 0 },
-		{ X86_FEATURE_SPEC_CTRL,	CPUID_EDX,26, 0x00000007, 0 },
-		{ X86_FEATURE_INTEL_STIBP,	CPUID_EDX,27, 0x00000007, 0 },
-		{ X86_FEATURE_FLUSH_L1D,	CPUID_EDX,28, 0x00000007, 0 },
-		{ X86_FEATURE_ARCH_CAPABILITIES, CPUID_EDX,29, 0x00000007, 0 },
-		{ X86_FEATURE_SPEC_CTRL_SSBD,	CPUID_EDX,31, 0x00000007, 0 },
-		{ X86_FEATURE_HW_PSTATE,	CPUID_EDX, 7, 0x80000007, 0 },
-		{ X86_FEATURE_CPB,		CPUID_EDX, 9, 0x80000007, 0 },
-		{ X86_FEATURE_PROC_FEEDBACK,	CPUID_EDX,11, 0x80000007, 0 },
-		{ X86_FEATURE_NPT,		CPUID_EDX, 0, 0x8000000a, 0 },
-		{ X86_FEATURE_LBRV,		CPUID_EDX, 1, 0x8000000a, 0 },
-		{ X86_FEATURE_SVML,		CPUID_EDX, 2, 0x8000000a, 0 },
-		{ X86_FEATURE_NRIPS,		CPUID_EDX, 3, 0x8000000a, 0 },
-		{ X86_FEATURE_TSCRATEMSR,	CPUID_EDX, 4, 0x8000000a, 0 },
-		{ X86_FEATURE_VMCBCLEAN,	CPUID_EDX, 5, 0x8000000a, 0 },
-		{ X86_FEATURE_FLUSHBYASID,	CPUID_EDX, 6, 0x8000000a, 0 },
-		{ X86_FEATURE_DECODEASSISTS,	CPUID_EDX, 7, 0x8000000a, 0 },
-		{ X86_FEATURE_PAUSEFILTER,	CPUID_EDX,10, 0x8000000a, 0 },
-		{ X86_FEATURE_PFTHRESHOLD,	CPUID_EDX,12, 0x8000000a, 0 },
-		{ X86_FEATURE_AVIC,		CPUID_EDX,13, 0x8000000a, 0 },
-		{ 0, 0, 0, 0, 0 }
-	};
-
 	for (cb = cpuid_bits; cb->feature; cb++) {
 
 		/* Verify that the level is valid */
@@ -76,3 +77,27 @@ void init_scattered_cpuid_features(struc
 			set_cpu_cap(c, cb->feature);
 	}
 }
+
+u32 get_scattered_cpuid_leaf(unsigned int level, unsigned int sub_leaf,
+			     enum cpuid_regs_idx reg)
+{
+	const struct cpuid_bit *cb;
+	u32 cpuid_val = 0;
+
+	for (cb = cpuid_bits; cb->feature; cb++) {
+
+		if (level > cb->level)
+			continue;
+
+		if (level < cb->level)
+			break;
+
+		if (reg == cb->reg && sub_leaf == cb->sub_leaf) {
+			if (cpu_has(&boot_cpu_data, cb->feature))
+				cpuid_val |= BIT(cb->bit);
+		}
+	}
+
+	return cpuid_val;
+}
+EXPORT_SYMBOL_GPL(get_scattered_cpuid_leaf);
