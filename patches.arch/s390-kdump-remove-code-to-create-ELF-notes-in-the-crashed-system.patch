From 8a07dd02d7615d91d65d6235f7232e3f9b5d347f Mon Sep 17 00:00:00 2001
From: Martin Schwidefsky <schwidefsky@de.ibm.com>
Date: Wed, 14 Oct 2015 15:53:06 +0200
Subject: [PATCH] s390/kdump: remove code to create ELF notes in the crashed
 system

References: bsc#1049706
Patch-mainline: v4.5-rc1
Git-commit: 8a07dd02d7615d91d65d6235f7232e3f9b5d347f

The s390 architecture can store the CPU registers of the crashed system
after the kdump kernel has been started and this is the preferred way.
Remove the remaining code fragments that deal with storing CPU registers
while the crashed system is still active.

Acked-by: Michael Holzheu <holzheu@linux.vnet.ibm.com>
Signed-off-by: Martin Schwidefsky <schwidefsky@de.ibm.com>
Acked-by: Michal Suchanek <msuchanek@suse.de>
---
 arch/s390/include/asm/elf.h      |    2 -
 arch/s390/kernel/crash_dump.c    |   24 ++--------------------
 arch/s390/kernel/machine_kexec.c |   42 ++++++++++++++++-----------------------
 arch/s390/kernel/setup.c         |   15 ++++---------
 arch/s390/kernel/smp.c           |    8 +------
 5 files changed, 28 insertions(+), 63 deletions(-)

--- a/arch/s390/include/asm/elf.h
+++ b/arch/s390/include/asm/elf.h
@@ -237,6 +237,4 @@ struct linux_binprm;
 #define ARCH_HAS_SETUP_ADDITIONAL_PAGES 1
 int arch_setup_additional_pages(struct linux_binprm *, int);
 
-void *fill_cpu_elf_notes(void *ptr, struct save_area *sa, __vector128 *vxrs);
-
 #endif
--- a/arch/s390/kernel/crash_dump.c
+++ b/arch/s390/kernel/crash_dump.c
@@ -75,11 +75,6 @@ static int copy_from_realmem(void *dest,
 }
 
 /*
- * Pointer to ELF header in new kernel
- */
-static void *elfcorehdr_newmem;
-
-/*
  * Copy one page from zfcpdump "oldmem"
  *
  * For pages below HSA size memory from the HSA is copied. Otherwise
@@ -392,7 +387,8 @@ static void *nt_s390_vx_low(void *ptr, _
 /*
  * Fill ELF notes for one CPU with save area registers
  */
-void *fill_cpu_elf_notes(void *ptr, struct save_area *sa, __vector128 *vx_regs)
+static void *fill_cpu_elf_notes(void *ptr, struct save_area *sa,
+				__vector128 *vx_regs)
 {
 	ptr = nt_prstatus(ptr, sa);
 	ptr = nt_fpregset(ptr, sa);
@@ -590,9 +586,6 @@ int elfcorehdr_alloc(unsigned long long
 	/* If we are not in kdump or zfcpdump mode return */
 	if (!OLDMEM_BASE && ipl_info.type != IPL_TYPE_FCP_DUMP)
 		return 0;
-	/* If elfcorehdr= has been passed via cmdline, we use that one */
-	if (elfcorehdr_addr != ELFCORE_ADDR_MAX)
-		return 0;
 	/* If we cannot get HSA size for zfcpdump return error */
 	if (ipl_info.type == IPL_TYPE_FCP_DUMP && !sclp.hsa_size)
 		return -ENODEV;
@@ -623,7 +616,6 @@ int elfcorehdr_alloc(unsigned long long
 	hdr_off = PTR_DIFF(ptr, hdr);
 	loads_init(phdr_loads, hdr_off);
 	*addr = (unsigned long long) hdr;
-	elfcorehdr_newmem = hdr;
 	*size = (unsigned long long) hdr_off;
 	BUG_ON(elfcorehdr_size > alloc_size);
 	return 0;
@@ -634,8 +626,6 @@ int elfcorehdr_alloc(unsigned long long
  */
 void elfcorehdr_free(unsigned long long addr)
 {
-	if (!elfcorehdr_newmem)
-		return;
 	kfree((void *)(unsigned long)addr);
 }
 
@@ -646,7 +636,6 @@ ssize_t elfcorehdr_read(char *buf, size_
 {
 	void *src = (void *)(unsigned long)*ppos;
 
-	src = elfcorehdr_newmem ? src : src - OLDMEM_BASE;
 	memcpy(buf, src, count);
 	*ppos += count;
 	return count;
@@ -658,15 +647,8 @@ ssize_t elfcorehdr_read(char *buf, size_
 ssize_t elfcorehdr_read_notes(char *buf, size_t count, u64 *ppos)
 {
 	void *src = (void *)(unsigned long)*ppos;
-	int rc;
 
-	if (elfcorehdr_newmem) {
-		memcpy(buf, src, count);
-	} else {
-		rc = copy_from_oldmem(buf, src, count);
-		if (rc)
-			return rc;
-	}
+	memcpy(buf, src, count);
 	*ppos += count;
 	return count;
 }
--- a/arch/s390/kernel/machine_kexec.c
+++ b/arch/s390/kernel/machine_kexec.c
@@ -35,43 +35,37 @@ extern const unsigned long long relocate
 #ifdef CONFIG_CRASH_DUMP
 
 /*
- * Create ELF notes for one CPU
- */
-static void add_elf_notes(int cpu)
-{
-	struct save_area *sa = (void *) 4608 + store_prefix();
-	void *ptr;
-
-	memcpy((void *) (4608UL + sa->pref_reg), sa, sizeof(*sa));
-	ptr = (u64 *) per_cpu_ptr(crash_notes, cpu);
-	ptr = fill_cpu_elf_notes(ptr, sa, NULL);
-	memset(ptr, 0, sizeof(struct elf_note));
-}
-
-/*
  * Initialize CPU ELF notes
  */
 static void setup_regs(void)
 {
-	unsigned long sa = S390_lowcore.prefixreg_save_area + SAVE_AREA_BASE;
-	struct _lowcore *lc;
+	struct save_area *sa, *sa_0;
+	unsigned long prefix;
 	int cpu, this_cpu;
 
-	/* Get lowcore pointer from store status of this CPU (absolute zero) */
-	lc = (struct _lowcore *)(unsigned long)S390_lowcore.prefixreg_save_area;
+	/* setup_regs is called with the prefix register = 0 */
+	sa_0 = (struct save_area *) SAVE_AREA_BASE;
+
+	/* Get status of this CPU out of absolute zero */
+	prefix = (unsigned long) S390_lowcore.prefixreg_save_area;
+	sa = (struct save_area *)(prefix + SAVE_AREA_BASE);
+	memcpy(sa, sa_0, sizeof(struct save_area));
+	if (MACHINE_HAS_VX) {
+		struct _lowcore *lc = (struct _lowcore *) prefix;
+		save_vx_regs_safe((void *) lc->vector_save_area_addr);
+	}
+
+	/* Get status of the other CPUs */
 	this_cpu = smp_find_processor_id(stap());
-	add_elf_notes(this_cpu);
 	for_each_online_cpu(cpu) {
 		if (cpu == this_cpu)
 			continue;
 		if (smp_store_status(cpu))
 			continue;
-		add_elf_notes(cpu);
+		prefix = (unsigned long) S390_lowcore.prefixreg_save_area;
+		sa = (struct save_area *)(prefix + SAVE_AREA_BASE);
+		memcpy(sa, sa_0, sizeof(struct save_area));
 	}
-	if (MACHINE_HAS_VX)
-		save_vx_regs_safe((void *) lc->vector_save_area_addr);
-	/* Copy dump CPU store status info to absolute zero */
-	memcpy((void *) SAVE_AREA_BASE, (void *) sa, sizeof(struct save_area));
 }
 
 /*
--- a/arch/s390/kernel/setup.c
+++ b/arch/s390/kernel/setup.c
@@ -669,15 +669,6 @@ static void __init reserve_kernel(void)
 #endif
 }
 
-static void __init reserve_elfcorehdr(void)
-{
-#ifdef CONFIG_CRASH_DUMP
-	if (is_kdump_kernel())
-		memblock_reserve(elfcorehdr_addr - OLDMEM_BASE,
-				 PAGE_ALIGN(elfcorehdr_size));
-#endif
-}
-
 static void __init setup_memory(void)
 {
 	struct memblock_region *reg;
@@ -864,6 +855,11 @@ void __init setup_arch(char **cmdline_p)
 		nospec_auto_detect();
 
 	parse_early_param();
+#ifdef CONFIG_CRASH_DUMP
+	/* Deactivate elfcorehdr= kernel parameter */
+	elfcorehdr_addr = ELFCORE_ADDR_MAX;
+#endif
+
 	os_info_init();
 	setup_ipl();
 
@@ -872,7 +868,6 @@ void __init setup_arch(char **cmdline_p)
 	reserve_oldmem();
 	reserve_kernel();
 	reserve_initrd();
-	reserve_elfcorehdr();
 	memblock_allow_resize();
 
 	/* Get information about *all* installed memory */
--- a/arch/s390/kernel/smp.c
+++ b/arch/s390/kernel/smp.c
@@ -612,9 +612,8 @@ int smp_store_status(int cpu)
  *    stored the registers of the boot CPU in the memory of the old system.
  * 4) kdump and the old kernel stored the CPU state
  *    condition: OLDMEM_BASE != NULL && is_kdump_kernel()
- *    The state of all CPUs is stored in ELF sections in the memory of the
- *    old system. The ELF sections are picked up by the crash_dump code
- *    via elfcorehdr_addr.
+ *    This case does not exist for s390 anymore, setup_arch explicitly
+ *    deactivates the elfcorehdr= kernel parameter
  */
 void __init smp_save_dump_cpus(void)
 {
@@ -623,9 +622,6 @@ void __init smp_save_dump_cpus(void)
 	struct save_area_ext *sa_ext;
 	bool is_boot_cpu;
 
-	if (is_kdump_kernel())
-		/* Previous system stored the CPU states. Nothing to do. */
-		return;
 	if (!(OLDMEM_BASE || ipl_info.type == IPL_TYPE_FCP_DUMP))
 		/* No previous system present, normal boot. */
 		return;
