From: Josef Bacik <josef@redhat.com>
Date: Thu, 18 Aug 2011 15:10:26 -0400
Patch-mainline: pending
References: FATE#306586
Git-commit-unstable: 9b3bf3fe3aa6fcaf667ac8e9632c46cda461a87e
Subject: [PATCH] fs: fix how we clear DCACHE_NEED_LOOKUP

We've been hitting random -ENOENT's with stress testing btrfs, and it turns out
it's because we're clearing the DCACHE_NEED_LOOKUP flag too early.  We clear it
before we actually have done the lookup, so there is a short period where a
process doing a lookup can come upon the stub dentry still on the hash list and
get it, and then have the flag cleared before it checks for it and will return a
dentry with no d_inode, thus resulting in a -ENOENT.  So instead of allowing the
fs to clear DCACHE_NEED_LOOKUP, instead make it be cleared in __d_instantiate
when we set the d_inode.  This way anybody doing the rcu lookup will have to be
refreshed because we do the rcu seq barrier on the dentry and it will get the
inode.  With this patch the reproducer no longer reproduces the problem.
Thanks,

Signed-off-by: Josef Bacik <josef@redhat.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/inode.c       |    1 -
 fs/dcache.c            |   29 ++++-------------------------
 include/linux/dcache.h |    2 --
 3 files changed, 4 insertions(+), 28 deletions(-)

Index: linux-3.0-SLE11-SP2-3.0/fs/btrfs/inode.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/fs/btrfs/inode.c
+++ linux-3.0-SLE11-SP2-3.0/fs/btrfs/inode.c
@@ -3959,7 +3959,6 @@ struct inode *btrfs_lookup_dentry(struct
 		memcpy(&location, dentry->d_fsdata, sizeof(struct btrfs_key));
 		kfree(dentry->d_fsdata);
 		dentry->d_fsdata = NULL;
-		d_clear_need_lookup(dentry);
 	} else {
 		ret = btrfs_inode_by_name(dir, dentry, &location);
 	}
Index: linux-3.0-SLE11-SP2-3.0/fs/dcache.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/fs/dcache.c
+++ linux-3.0-SLE11-SP2-3.0/fs/dcache.c
@@ -344,24 +344,6 @@ void d_drop(struct dentry *dentry)
 EXPORT_SYMBOL(d_drop);
 
 /*
- * d_clear_need_lookup - drop a dentry from cache and clear the need lookup flag
- * @dentry: dentry to drop
- *
- * This is called when we do a lookup on a placeholder dentry that needed to be
- * looked up.  The dentry should have been hashed in order for it to be found by
- * the lookup code, but now needs to be unhashed while we do the actual lookup
- * and clear the DCACHE_NEED_LOOKUP flag.
- */
-void d_clear_need_lookup(struct dentry *dentry)
-{
-	spin_lock(&dentry->d_lock);
-	__d_drop(dentry);
-	dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
-	spin_unlock(&dentry->d_lock);
-}
-EXPORT_SYMBOL(d_clear_need_lookup);
-
-/*
  * Finish off a dentry we've decided to kill.
  * dentry->d_lock must be held, returns with it unlocked.
  * If ref is non-zero, then decrement the refcount too.
@@ -1399,6 +1381,10 @@ static void __d_instantiate(struct dentr
 		list_add(&dentry->d_alias, &inode->i_dentry);
 	}
 	dentry->d_inode = inode;
+	if (d_need_lookup(dentry)) {
+		__d_drop(dentry);
+		dentry->d_flags &= ~DCACHE_NEED_LOOKUP;
+	}
 	dentry_rcuwalk_barrier(dentry);
 	spin_unlock(&dentry->d_lock);
 	fsnotify_d_instantiate(dentry, inode);
@@ -1731,13 +1717,6 @@ struct dentry *d_add_ci(struct dentry *d
 	}
 
 	/*
-	 * We are going to instantiate this dentry, unhash it and clear the
-	 * lookup flag so we can do that.
-	 */
-	if (unlikely(d_need_lookup(found)))
-		d_clear_need_lookup(found);
-
-	/*
 	 * Negative dentry: instantiate it unless the inode is a directory and
 	 * already has a dentry.
 	 */
Index: linux-3.0-SLE11-SP2-3.0/include/linux/dcache.h
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/include/linux/dcache.h
+++ linux-3.0-SLE11-SP2-3.0/include/linux/dcache.h
@@ -422,7 +422,6 @@ static inline bool d_need_lookup(struct
 	return dentry->d_flags & DCACHE_NEED_LOOKUP;
 }
 
-extern void d_clear_need_lookup(struct dentry *dentry);
 extern struct dentry *lookup_create(struct nameidata *nd, int is_dir);
 
 extern int sysctl_vfs_cache_pressure;
