From: Hannes Reinecke <hare@suse.de>
Subject: DASD: Add 'timeout' attribute
References: bnc#771361
Patch-Mainline: n/a, under discussion with upstream

This patch adds a 'timeout' attibute to the DASD driver.
For upstream the 'failfast_XXX' attributes are not acceptable,
whereas the block timeout function is. But the timeout should
be controlled by a single attribute, which relates directly
to the block timeout.

So introduce a new 'timeout' sysfs attribute, and treat the
previous 'failfast_retries' and 'failfast_expires' as legacy.
The default value of the 'timeout' attribute is
(failfast_retries + 1) * failfast_expires

We need to add '1' here as the I/O has already run once
before the retry, thereby incurring one additional timeout.

Signed-off-by: Hannes Reinecke <hare@suse.de>

diff --git a/drivers/s390/block/dasd.c b/drivers/s390/block/dasd.c
index 198aa27..ba8a11e 100644
--- a/drivers/s390/block/dasd.c
+++ b/drivers/s390/block/dasd.c
@@ -2406,7 +2406,6 @@ static int dasd_alloc_queue(struct dasd_block *block)
 static void dasd_setup_queue(struct dasd_block *block)
 {
 	int max;
-	unsigned int timeout;
 
 	if (block->base->features & DASD_FEATURE_USERAW) {
 		/*
@@ -2435,8 +2434,10 @@ static void dasd_setup_queue(struct dasd_block *block)
 	 * dasd_times_out() will ignore requests when failfast
 	 * is not enabled.
 	 */
-	timeout = block->base->failfast_expires * block->base->failfast_retries;
-	blk_queue_rq_timeout(block->request_queue, timeout * HZ);
+	block->base->blk_timeout = block->base->failfast_expires *
+	    (block->base->failfast_retries + 1);
+	blk_queue_rq_timeout(block->request_queue,
+			     block->base->blk_timeout * HZ);
 }
 
 /*
diff --git a/drivers/s390/block/dasd_devmap.c b/drivers/s390/block/dasd_devmap.c
index a90e2de..98cd889 100644
--- a/drivers/s390/block/dasd_devmap.c
+++ b/drivers/s390/block/dasd_devmap.c
@@ -1232,7 +1232,7 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val, timeout;
+	unsigned long val;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1244,11 +1244,10 @@ dasd_failfast_expires_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val) {
-		device->failfast_expires = val;
-		timeout = val * device->failfast_retries;
-		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
-	}
+	device->failfast_expires = val;
+	device->blk_timeout = val * (device->failfast_retries + 1);
+	blk_queue_rq_timeout(device->block->request_queue,
+			     device->blk_timeout * HZ);
 
 	dasd_put_device(device);
 	return count;
@@ -1317,7 +1316,7 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 	       const char *buf, size_t count)
 {
 	struct dasd_device *device;
-	unsigned long val, timeout;
+	unsigned long val;
 
 	device = dasd_device_from_cdev(to_ccwdev(dev));
 	if (IS_ERR(device))
@@ -1329,11 +1328,10 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 		return -EINVAL;
 	}
 
-	if (val) {
-		device->failfast_retries = val;
-		timeout = val * device->failfast_expires;
-		blk_queue_rq_timeout(device->block->request_queue, timeout * HZ);
-	}
+	device->failfast_retries = val;
+	device->blk_timeout = (val + 1) * device->failfast_expires;
+	blk_queue_rq_timeout(device->block->request_queue,
+			     device->blk_timeout * HZ);
 
 	dasd_put_device(device);
 	return count;
@@ -1342,6 +1340,55 @@ dasd_failfast_retries_store(struct device *dev, struct device_attribute *attr,
 static DEVICE_ATTR(failfast_retries, 0644,
 		   dasd_failfast_retries_show, dasd_failfast_retries_store);
 
+static ssize_t
+dasd_timeout_show(struct device *dev, struct device_attribute *attr,
+		  char *buf)
+{
+	struct dasd_device *device;
+	int len;
+
+	device = dasd_device_from_cdev(to_ccwdev(dev));
+	if (IS_ERR(device))
+		return -ENODEV;
+	len = snprintf(buf, PAGE_SIZE, "%lu\n", device->blk_timeout);
+	dasd_put_device(device);
+	return len;
+}
+
+static ssize_t
+dasd_timeout_store(struct device *dev, struct device_attribute *attr,
+		   const char *buf, size_t count)
+{
+	struct dasd_device *device;
+	unsigned long val;
+
+	device = dasd_device_from_cdev(to_ccwdev(dev));
+	if (IS_ERR(device))
+		return -ENODEV;
+
+	if ((strict_strtoul(buf, 10, &val) != 0) ||
+	    val > (device->default_retries * device->default_expires) ||
+	    val == 0) {
+		dasd_put_device(device);
+		return -EINVAL;
+	}
+
+	device->blk_timeout = val;
+	device->failfast_expires = val / (device->failfast_retries + 1);
+	/* Make failfast_expires an upper boundary */
+	if (val % device->failfast_retries)
+		device->failfast_expires++;
+
+	blk_queue_rq_timeout(device->block->request_queue,
+			     device->blk_timeout * HZ);
+
+	dasd_put_device(device);
+	return count;
+}
+
+static DEVICE_ATTR(timeout, 0644,
+		   dasd_timeout_show, dasd_timeout_store);
+
 static ssize_t dasd_reservation_policy_show(struct device *dev,
 					    struct device_attribute *attr,
 					    char *buf)
@@ -1455,6 +1502,7 @@ static struct attribute * dasd_attrs[] = {
 	&dev_attr_failfast_expires.attr,
 	&dev_attr_retries.attr,
 	&dev_attr_failfast_retries.attr,
+	&dev_attr_timeout.attr,
 	&dev_attr_reservation_policy.attr,
 	&dev_attr_last_known_reservation_state.attr,
 	NULL,
diff --git a/drivers/s390/block/dasd_int.h b/drivers/s390/block/dasd_int.h
index de9e30d..0eea4f2 100644
--- a/drivers/s390/block/dasd_int.h
+++ b/drivers/s390/block/dasd_int.h
@@ -438,6 +438,7 @@ struct dasd_device {
 	unsigned long failfast_expires;
 	unsigned long default_retries;
 	unsigned long failfast_retries;
+	unsigned long blk_timeout;
 };
 
 struct dasd_block {
