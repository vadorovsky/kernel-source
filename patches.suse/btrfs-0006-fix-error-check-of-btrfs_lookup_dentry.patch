From 7aa3be8e45288cc3062e283ee93eedd3c8f6d808 Mon Sep 17 00:00:00 2001
From: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Date: Mon, 15 Aug 2011 14:12:47 -0700
Subject: [PATCH 06/20] btrfs: fix error check of btrfs_lookup_dentry()
Patch-mainline: No

Clean up btrfs_lookup_dentry() to never return NULL, but PTR_ERR(-ENOENT)
instead. This keeps the return value convention consistent.

Callers who pass to d_instatiate() require a trivial update.

create_snapshot() in particular looks like it can also lose a BUG_ON(!inode)
which is not really needed - there seems less harm in returning ENOENT to
userspace at that point in the stack than there is to crash the machine.

Mark: Fixed conflicts against latest tree, gave the patch a more thorough
description.

Signed-off-by: Tsutomu Itoh <t-itoh@jp.fujitsu.com>
Signed-off-by: Mark Fasheh <mfasheh@suse.de>
---
 fs/btrfs/inode.c |   10 +++++++---
 fs/btrfs/ioctl.c |   11 +++++++++--
 2 files changed, 16 insertions(+), 5 deletions(-)

--- a/fs/btrfs/inode.c
+++ b/fs/btrfs/inode.c
@@ -3933,7 +3933,7 @@ struct inode *btrfs_lookup_dentry(struct
 		return ERR_PTR(ret);
 
 	if (location.objectid == 0)
-		return NULL;
+		return ERR_PTR(-ENOENT);
 
 	if (location.type == BTRFS_INODE_ITEM_KEY) {
 		inode = btrfs_iget(dir->i_sb, &location, root, NULL);
@@ -3995,8 +3995,12 @@ static struct dentry *btrfs_lookup(struc
 	struct dentry *ret;
 
 	inode = btrfs_lookup_dentry(dir, dentry);
-	if (IS_ERR(inode))
-		return ERR_CAST(inode);
+ 	if (IS_ERR(inode)) {
+ 		if (PTR_ERR(inode) == -ENOENT)
+ 			inode = NULL;
+ 		else
+ 			return ERR_CAST(inode);
+ 	}
 
 	ret = d_splice_alias(inode, dentry);
 	if (unlikely(d_need_lookup(dentry))) {
--- a/fs/btrfs/ioctl.c
+++ b/fs/btrfs/ioctl.c
@@ -335,6 +335,7 @@ static noinline int create_subvol(struct
 	struct btrfs_root *new_root;
 	struct dentry *parent = dentry->d_parent;
 	struct inode *dir;
+	struct inode *inode;
 	int ret;
 	int err;
 	u64 objectid;
@@ -448,7 +449,13 @@ static noinline int create_subvol(struct
 
 	BUG_ON(ret);
 
-	d_instantiate(dentry, btrfs_lookup_dentry(dir, dentry));
+	inode = btrfs_lookup_dentry(dir, dentry);
+	if (IS_ERR(inode)) {
+		ret = PTR_ERR(inode);
+		goto fail;
+	}
+
+	d_instantiate(dentry, inode);
 fail:
 	if (async_transid) {
 		*async_transid = trans->transid;
@@ -518,7 +525,7 @@ static int create_snapshot(struct btrfs_
 		ret = PTR_ERR(inode);
 		goto fail;
 	}
-	BUG_ON(!inode);
+
 	d_instantiate(dentry, inode);
 	ret = 0;
 fail:
