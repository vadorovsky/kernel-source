From: Nick Piggin <npiggin@suse.de>
References: FATE309111
Subject: uninline add_to_page_cache
Patch-mainline: no

Uninline add_to_page_cache so that we can add to the function in a
subsequent patch (pagecache limiting) without changing the kABI.

Signed-off-by: Nick Piggin <npiggin@suse.de>
--
Index: linux-3.0-tmp-jikos/include/linux/pagemap.h
===================================================================
--- linux-3.0-tmp-jikos.orig/include/linux/pagemap.h
+++ linux-3.0-tmp-jikos/include/linux/pagemap.h
@@ -454,6 +454,8 @@ static inline int fault_in_pages_readabl
 	return ret;
 }
 
+int add_to_page_cache(struct page *page, struct address_space *mapping,
+				pgoff_t index, gfp_t gfp_mask);
 int add_to_page_cache_locked(struct page *page, struct address_space *mapping,
 				pgoff_t index, gfp_t gfp_mask);
 int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
@@ -462,20 +464,4 @@ extern void delete_from_page_cache(struc
 extern void __delete_from_page_cache(struct page *page);
 int replace_page_cache_page(struct page *old, struct page *new, gfp_t gfp_mask);
 
-/*
- * Like add_to_page_cache_locked, but used to add newly allocated pages:
- * the page is new, so we can just run __set_page_locked() against it.
- */
-static inline int add_to_page_cache(struct page *page,
-		struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask)
-{
-	int error;
-
-	__set_page_locked(page);
-	error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
-	if (unlikely(error))
-		__clear_page_locked(page);
-	return error;
-}
-
 #endif /* _LINUX_PAGEMAP_H */
Index: linux-3.0-tmp-jikos/mm/filemap.c
===================================================================
--- linux-3.0-tmp-jikos.orig/mm/filemap.c
+++ linux-3.0-tmp-jikos/mm/filemap.c
@@ -500,6 +500,23 @@ out:
 }
 EXPORT_SYMBOL(add_to_page_cache_locked);
 
+/*
+ * Like add_to_page_cache_locked, but used to add newly allocated pages:
+ * the page is new, so we can just run __set_page_locked() against it.
+ */
+int add_to_page_cache(struct page *page,
+		struct address_space *mapping, pgoff_t offset, gfp_t gfp_mask)
+{
+	int error;
+
+	__set_page_locked(page);
+	error = add_to_page_cache_locked(page, mapping, offset, gfp_mask);
+	if (unlikely(error))
+		__clear_page_locked(page);
+	return error;
+}
+EXPORT_SYMBOL(add_to_page_cache);
+
 int add_to_page_cache_lru(struct page *page, struct address_space *mapping,
 				pgoff_t offset, gfp_t gfp_mask)
 {
