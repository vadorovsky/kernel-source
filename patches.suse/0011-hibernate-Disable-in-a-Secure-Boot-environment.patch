From: Josh Boyer <jwboyer@redhat.com>
Date: Fri, 26 Oct 2012 14:02:09 -0400
Subject: [PATCH] hibernate: Disable in a Secure Boot environment
Git-commit: Not yet, reviewing
Patch-mainline: Not yet, reviewing
References: fate#314486
Target: SLE-11 SP3

There is currently no way to verify the resume image when returning
from hibernate.  This might compromise the secure boot trust model,
so until we can work with signed hibernate images we disable it in
a Secure Boot environment.

Signed-off-by: Josh Boyer <jwboyer@redhat.com>
Signed-off-by: Matthew Garrett <mjg@redhat.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com
---
 v2: Updated to include swsup after feedback from Jiri Kosina <jkosina@suse.cz>

 kernel/power/hibernate.c |   15 ++++++++++++++-
 kernel/power/main.c      |    7 ++++++-
 kernel/power/user.c      |    3 +++
 3 files changed, 23 insertions(+), 2 deletions(-)

--- a/kernel/power/hibernate.c
+++ b/kernel/power/hibernate.c
@@ -24,6 +24,7 @@
 #include <linux/freezer.h>
 #include <linux/gfp.h>
 #include <linux/syscore_ops.h>
+#include <linux/efi.h>
 
 #include "power.h"
 
@@ -609,6 +610,10 @@ int hibernate(void)
 {
 	int error;
 
+	if (!capable(CAP_COMPROMISE_KERNEL)) {
+		return -EPERM;
+	}
+
 	mutex_lock(&pm_mutex);
 	/* The snapshot device should not be opened while we're running */
 	if (!atomic_add_unless(&snapshot_device_available, -1, 0)) {
@@ -705,7 +710,7 @@ static int software_resume(void)
 	/*
 	 * If the user said "noresume".. bail out early.
 	 */
-	if (noresume)
+	if (noresume || !capable(CAP_COMPROMISE_KERNEL))
 		return 0;
 
 	/*
@@ -854,6 +859,11 @@ static ssize_t disk_show(struct kobject
 	int i;
 	char *start = buf;
 
+	if (secure_boot_enabled) {
+		buf += sprintf(buf, "[%s]\n", "disabled");
+		return buf-start;
+	}
+
 	for (i = HIBERNATION_FIRST; i <= HIBERNATION_MAX; i++) {
 		if (!hibernation_modes[i])
 			continue;
@@ -887,6 +897,9 @@ static ssize_t disk_store(struct kobject
 	char *p;
 	int mode = HIBERNATION_INVALID;
 
+	if (!capable(CAP_COMPROMISE_KERNEL))
+		return -EPERM;
+
 	p = memchr(buf, '\n', n);
 	len = p ? p - buf : n;
 
--- a/kernel/power/main.c
+++ b/kernel/power/main.c
@@ -12,6 +12,7 @@
 #include <linux/string.h>
 #include <linux/resume-trace.h>
 #include <linux/workqueue.h>
+#include <linux/efi.h>
 
 #include "power.h"
 
@@ -157,7 +158,11 @@ static ssize_t state_show(struct kobject
 	}
 #endif
 #ifdef CONFIG_HIBERNATION
-	s += sprintf(s, "%s\n", "disk");
+	if (!secure_boot_enabled) {
+		s += sprintf(s, "%s\n", "disk");
+	} else {
+		s += sprintf(s, "\n");
+	}
 #else
 	if (s != buf)
 		/* convert the last space to a newline */
--- a/kernel/power/user.c
+++ b/kernel/power/user.c
@@ -69,6 +69,9 @@ static int snapshot_open(struct inode *i
 	struct snapshot_data *data;
 	int error;
 
+	if (!capable(CAP_COMPROMISE_KERNEL))
+		return -EPERM;
+
 	mutex_lock(&pm_mutex);
 
 	if (!atomic_add_unless(&snapshot_device_available, -1, 0)) {
