From: Jiri Kosina <jkosina@suse.cz>
Subject: PTI: unbreak EFI
References: bsc#1074709
Patch-mainline: Queued in subsystem maintainer repository
Git-commit: d9e9a6418065bb376e5de8d93ce346939b9a37a6
Git-commit: de53c3786a3ce162a1c815d0c04c766c23ec9c0a
Git-repo: git://git.kernel.org/pub/scm/linux/kernel/git/tip/tip.git#x86/pti

efi_call_phys_prolog() calls set_pgd() with swapper PGD that has PAGE_USER set,
which makes KAISER set NX on it, and therefore EFI can't execute it's code.

This problem exists only on systems with old EFI mmap.

Fix that by forcefully clearing _PAGE_NX from the PGD (this can't be done
by the pgprot API).

_PAGE_NX will be automatically reintroduced in efi_call_phys_epilog() by
kaiser_set_shadow_pgd().

This contains fixup from Kirill Shutemov from upstream that was
folded into d9e9a6418065bb376e5de8d93ce346939b9a37a6.

Thanks a lot for debugging help from Matt Fleming and Borislav Petkov.

Signed-off-by: Jiri Kosina <jkosina@suse.cz>
---
 arch/x86/include/asm/pgalloc.h |    7 +++++++
 arch/x86/mm/pgtable.c          |    7 -------
 arch/x86/platform/efi/efi_64.c |    8 +++++++-
 3 files changed, 14 insertions(+), 8 deletions(-)

--- a/arch/x86/include/asm/pgalloc.h
+++ b/arch/x86/include/asm/pgalloc.h
@@ -28,6 +28,13 @@ static inline void paravirt_release_pud(
 extern gfp_t __userpte_alloc_gfp;
 
 /*
+ * Instead of one pgd, Kaiser acquires two pgds.  Being order-1, it is
+ * both 8k in size and 8k-aligned.  That lets us just flip bit 12
+ * in a pointer to swap between the two 4k halves.
+ */
+#define PGD_ALLOCATION_ORDER    kaiser_enabled
+
+/*
  * Allocate and free page tables.
  */
 extern pgd_t *pgd_alloc(struct mm_struct *);
--- a/arch/x86/mm/pgtable.c
+++ b/arch/x86/mm/pgtable.c
@@ -341,13 +341,6 @@ static inline void _pgd_free(pgd_t *pgd)
 }
 #else
 
-/*
- * Instead of one pgd, Kaiser acquires two pgds.  Being order-1, it is
- * both 8k in size and 8k-aligned.  That lets us just flip bit 12
- * in a pointer to swap between the two 4k halves.
- */
-#define PGD_ALLOCATION_ORDER	kaiser_enabled
-
 static inline pgd_t *_pgd_alloc(void)
 {
 	/* No __GFP_REPEAT: to avoid page allocation stalls in order-1 case */
--- a/arch/x86/platform/efi/efi_64.c
+++ b/arch/x86/platform/efi/efi_64.c
@@ -88,6 +88,12 @@ pgd_t * __init efi_call_phys_prolog(void
 		save_pgd[pgd] = *pgd_offset_k(pgd * PGDIR_SIZE);
 		vaddress = (unsigned long)__va(pgd * PGDIR_SIZE);
 		set_pgd(pgd_offset_k(pgd * PGDIR_SIZE), *pgd_offset_k(vaddress));
+		/*
+		 * pgprot API doesn't clear it for PGD
+		 *
+		 * Will be brought back automatically in _epilog()
+		 */
+		pgd_offset_k(pgd * PGDIR_SIZE)->pgd &= ~_PAGE_NX;
 	}
 out:
 	__flush_tlb_all();
@@ -138,7 +144,7 @@ int __init efi_alloc_page_tables(void)
 		return 0;
 
 	gfp_mask = GFP_KERNEL | __GFP_NOTRACK | __GFP_REPEAT | __GFP_ZERO;
-	efi_pgd = (pgd_t *)__get_free_page(gfp_mask);
+	efi_pgd = (pgd_t *)__get_free_pages(gfp_mask, PGD_ALLOCATION_ORDER);
 	if (!efi_pgd)
 		return -ENOMEM;
 
