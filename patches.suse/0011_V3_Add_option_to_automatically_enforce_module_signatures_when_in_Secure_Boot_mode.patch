From: Matthew Garrett <matthew.garrett@nebula.com>
Subject: [PATCH V3 11/11] Add option to automatically enforce module signatures when in Secure Boot mode
Date: Tue,  3 Sep 2013 19:50:18 -0400

Git-commit: Not yet
Patch-mainline: Not yet, fedora 20
References: fate#314486, bnc#884333
Target: SLE-11 SP3

UEFI Secure Boot provides a mechanism for ensuring that the firmware will
only load signed bootloaders and kernels. Certain use cases may also
require that all kernel modules also be signed. Add a configuration option
that enforces this automatically when enabled.

Signed-off-by: Matthew Garrett <matthew.garrett@nebula.com>
Acked-by: Lee, Chun-Yi <jlee@suse.com>

---
 Documentation/x86/zero-page.txt       |  2 ++
 arch/x86/Kconfig                      | 10 ++++++++++
 arch/x86/boot/compressed/eboot.c      | 36 +++++++++++++++++++++++++++++++++++
 arch/x86/include/uapi/asm/bootparam.h |  3 ++-
 arch/x86/kernel/setup.c               |  6 ++++++
 include/linux/module.h                |  6 ++++++
 kernel/module.c                       |  7 +++++++
 7 files changed, 69 insertions(+), 1 deletion(-)

Index: linux-3.0-SLE11-SP4/Documentation/x86/zero-page.txt
===================================================================
--- linux-3.0-SLE11-SP4.orig/Documentation/x86/zero-page.txt
+++ linux-3.0-SLE11-SP4/Documentation/x86/zero-page.txt
@@ -27,6 +27,7 @@ Offset	Proto	Name		Meaning
 1E9/001	ALL	eddbuf_entries	Number of entries in eddbuf (below)
 1EA/001	ALL	edd_mbr_sig_buf_entries	Number of entries in edd_mbr_sig_buffer
 				(below)
+1EB/001	ALL     secure_boot     Secure boot is enabled in the firmware
 290/040	ALL	edd_mbr_sig_buffer EDD MBR signatures
 2D0/A00	ALL	e820_map	E820 memory map table
 				(array of struct e820entry)
Index: linux-3.0-SLE11-SP4/arch/x86/boot/compressed/eboot.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/arch/x86/boot/compressed/eboot.c
+++ linux-3.0-SLE11-SP4/arch/x86/boot/compressed/eboot.c
@@ -724,6 +724,37 @@ fail:
 	return status;
 }
 
+static int get_secure_boot(void)
+{
+	u8 sb, setup;
+	unsigned long datasize = sizeof(sb);
+	efi_guid_t var_guid = EFI_GLOBAL_VARIABLE_GUID;
+	efi_status_t status;
+
+	status = efi_call_phys5(sys_table->runtime->get_variable,
+				L"SecureBoot", &var_guid, NULL, &datasize, &sb);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (sb == 0)
+		return 0;
+
+
+	status = efi_call_phys5(sys_table->runtime->get_variable,
+				L"SetupMode", &var_guid, NULL, &datasize,
+				&setup);
+
+	if (status != EFI_SUCCESS)
+		return 0;
+
+	if (setup == 1)
+		return 0;
+
+	return 1;
+}
+
+
 /*
  * Because the x86 boot code expects to be passed a boot_params we
  * need to create one ourselves (usually the bootloader would create
@@ -1018,6 +1049,8 @@ struct boot_params *efi_main(void *handl
 	if (sys_table->hdr.signature != EFI_SYSTEM_TABLE_SIGNATURE)
 		goto fail;
 
+	boot_params->secure_boot = get_secure_boot();
+
 	setup_graphics(boot_params);
 
 	status = efi_call_phys3(sys_table->boottime->allocate_pool,
Index: linux-3.0-SLE11-SP4/arch/x86/kernel/setup.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/arch/x86/kernel/setup.c
+++ linux-3.0-SLE11-SP4/arch/x86/kernel/setup.c
@@ -1052,6 +1052,11 @@ void __init setup_arch(char **cmdline_p)
 
 	io_delay_init();
 
+	if (boot_params.secure_boot) {
+		pr_info("Secure boot enabled\n");
+		enforce_signed_modules();
+	}
+
 	/*
 	 * Parse the ACPI tables for possible boot-time SMP configuration.
 	 */
Index: linux-3.0-SLE11-SP4/include/linux/module.h
===================================================================
--- linux-3.0-SLE11-SP4.orig/include/linux/module.h
+++ linux-3.0-SLE11-SP4/include/linux/module.h
@@ -204,6 +204,12 @@ const struct exception_table_entry *sear
 
 struct notifier_block;
 
+#ifdef CONFIG_MODULE_SIG
+extern void enforce_signed_modules(void);
+#else
+static inline void enforce_signed_modules(void) {};
+#endif
+
 #ifdef CONFIG_MODULES
 
 extern int modules_disabled; /* for sysctl */
Index: linux-3.0-SLE11-SP4/kernel/module.c
===================================================================
--- linux-3.0-SLE11-SP4.orig/kernel/module.c
+++ linux-3.0-SLE11-SP4/kernel/module.c
@@ -3684,6 +3684,13 @@ int module_get_iter_tracepoints(struct t
 }
 #endif
 
+#ifdef CONFIG_MODULE_SIG
+void enforce_signed_modules(void)
+{
+	sig_enforce = true;
+}
+#endif
+
 bool secure_modules(void)
 {
 #ifdef CONFIG_MODULE_SIG
Index: linux-3.0-SLE11-SP4/arch/x86/include/asm/bootparam.h
===================================================================
--- linux-3.0-SLE11-SP4.orig/arch/x86/include/asm/bootparam.h
+++ linux-3.0-SLE11-SP4/arch/x86/include/asm/bootparam.h
@@ -113,7 +113,8 @@ struct boot_params {
 	__u8  e820_entries;				/* 0x1e8 */
 	__u8  eddbuf_entries;				/* 0x1e9 */
 	__u8  edd_mbr_sig_buf_entries;			/* 0x1ea */
-	__u8  _pad6[6];					/* 0x1eb */
+	__u8  secure_boot;                              /* 0x1eb */
+	__u8  _pad6[5];					/* 0x1ec */
 	struct setup_header hdr;    /* setup header */	/* 0x1f1 */
 	__u8  _pad7[0x290-0x1f1-sizeof(struct setup_header)];
 	__u32 edd_mbr_sig_buffer[EDD_MBR_SIG_MAX];	/* 0x290 */
