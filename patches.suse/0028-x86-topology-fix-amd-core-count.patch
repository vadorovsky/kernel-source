From: Peter Zijlstra <peterz@infradead.org>
Date: Fri, 25 Mar 2016 15:52:34 +0100
Subject: x86/topology: Fix AMD core count
Git-commit: ee6825c80e870fff1a370c718ec77022ade0889b
Patch-mainline: v4.6-rc2
References: FATE#319705 (supporting patches needed for exit_box)
Signed-off-by: Tony Jones <tonyj@suse.de>

    x86/topology: Fix AMD core count
    
    It turns out AMD gets x86_max_cores wrong when there are compute
    units.
    
    The issue is that Linux assumes:
    
            nr_logical_cpus = nr_cores * nr_siblings
    
    But AMD reports its CU unit as 2 cores, but then sets num_smp_siblings
    to 2 as well.
    
    Boris: fixup ras/mce_amd_inj.c too, to compute the Node Base Core
    properly, according to the new nomenclature.
    
    Fixes: 1f12e32f4cd5 ("x86/topology: Create logical package id")
    Reported-by: Xiong Zhou <jencce.kernel@gmail.com>
    Signed-off-by: Peter Zijlstra (Intel) <peterz@infradead.org>
    Signed-off-by: Borislav Petkov <bp@suse.de>
    Cc: Andreas Herrmann <aherrmann@suse.com>
    Cc: Andy Lutomirski <luto@kernel.org>
    Link: http://lkml.kernel.org/r/20160317095220.GO6344@twins.programming.kicks-ass.net
    Signed-off-by: Thomas Gleixner <tglx@linutronix.de>

---
 arch/x86/include/asm/smp.h |    1 +
 arch/x86/kernel/cpu/amd.c  |    8 ++++----
 arch/x86/ras/mce_amd_inj.c |    3 ++-
 3 files changed, 7 insertions(+), 5 deletions(-)

--- a/arch/x86/include/asm/smp.h
+++ b/arch/x86/include/asm/smp.h
@@ -170,6 +170,7 @@ static inline int wbinvd_on_all_cpus(voi
 	wbinvd();
 	return 0;
 }
+#define smp_num_siblings	1
 #endif /* CONFIG_SMP */
 
 extern unsigned disabled_cpus;
--- a/arch/x86/kernel/cpu/amd.c
+++ b/arch/x86/kernel/cpu/amd.c
@@ -312,9 +312,9 @@ static void amd_get_topology(struct cpui
 		node_id = ecx & 7;
 
 		/* get compute unit information */
-		smp_num_siblings = ((ebx >> 8) & 3) + 1;
+		cores_per_cu = smp_num_siblings = ((ebx >> 8) & 3) + 1;
+		c->x86_max_cores /= smp_num_siblings;
 		c->compute_unit_id = ebx & 0xff;
-		cores_per_cu += ((ebx >> 8) & 3);
 	} else if (cpu_has(c, X86_FEATURE_NODEID_MSR)) {
 		u64 value;
 
@@ -330,8 +330,8 @@ static void amd_get_topology(struct cpui
 		u32 cus_per_node;
 
 		set_cpu_cap(c, X86_FEATURE_AMD_DCM);
-		cores_per_node = c->x86_max_cores / nodes_per_socket;
-		cus_per_node = cores_per_node / cores_per_cu;
+		cus_per_node = c->x86_max_cores / nodes_per_socket;
+		cores_per_node = cus_per_node * cores_per_cu;
 
 		/* store NodeID, use llc_shared_map to store sibling info */
 		per_cpu(cpu_llc_id, cpu) = node_id;
--- a/arch/x86/ras/mce_amd_inj.c
+++ b/arch/x86/ras/mce_amd_inj.c
@@ -20,6 +20,7 @@
 #include <linux/pci.h>
 
 #include <asm/mce.h>
+#include <asm/smp.h>
 #include <asm/amd_nb.h>
 #include <asm/irq_vectors.h>
 
@@ -206,7 +207,7 @@ static u32 get_nbc_for_node(int node_id)
 	struct cpuinfo_x86 *c = &boot_cpu_data;
 	u32 cores_per_node;
 
-	cores_per_node = c->x86_max_cores / amd_get_nodes_per_socket();
+	cores_per_node = (c->x86_max_cores * smp_num_siblings) / amd_get_nodes_per_socket();
 
 	return cores_per_node * node_id;
 }
