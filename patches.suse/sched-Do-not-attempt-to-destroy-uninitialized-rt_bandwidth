Subject: sched: Do not attempt to destroy uninitialized rt_bandwidth
From: Bianca Lutz <sowilo@cs.tu-berlin.de>
Date: Wed, 13 Jul 2011 20:13:36 +0200
Git-commit: 99bc52429f11d1f4f81495ac8237085aaeb6bccf
Patch-mainline: not yet

If a task group is to be created and alloc_fair_sched_group() fails,
then the rt_bandwidth of the corresponding task group is not yet
initialized. The caller, sched_create_group(), starts a clean up
procedure which calls free_rt_sched_group() which unconditionally
destroys the not yet initialized rt_bandwidth.

This crashes or hangs the system in lock_hrtimer_base(): UP systems
dereference a NULL pointer, while SMP systems loop endlessly on a
condition that cannot become true.

This patch simply avoids the destruction of rt_bandwidth when the
initialization code path was not reached.

(This was discovered by accident with a custom kernel modification.)

Signed-off-by: Bianca Lutz <sowilo@cs.tu-berlin.de>
Signed-off-by: Jan Schoenherr <schnhrr@cs.tu-berlin.de>
Signed-off-by: Peter Zijlstra <a.p.zijlstra@chello.nl>
Link: http://lkml.kernel.org/r/1310580816-10861-7-git-send-email-schnhrr@cs.tu-berlin.de
Signed-off-by: Ingo Molnar <mingo@elte.hu>
Acked-by: Mike Galbraith <mgalbraith@suse.de>

---
 kernel/sched.c |    3 ++-
 1 file changed, 2 insertions(+), 1 deletion(-)

Index: linux-3.0-SLE11-SP2-3.0/kernel/sched.c
===================================================================
--- linux-3.0-SLE11-SP2-3.0.orig/kernel/sched.c
+++ linux-3.0-SLE11-SP2-3.0/kernel/sched.c
@@ -8392,7 +8392,8 @@ static void free_rt_sched_group(struct t
 {
 	int i;
 
-	destroy_rt_bandwidth(&tg->rt_bandwidth);
+	if (tg->rt_se)
+		destroy_rt_bandwidth(&tg->rt_bandwidth);
 
 	for_each_possible_cpu(i) {
 		if (tg->rt_rq)
