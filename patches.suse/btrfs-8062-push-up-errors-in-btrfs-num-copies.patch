From: David Sterba <dsterba@suse.cz>
Date: Wed, 14 Mar 2012 17:03:13 +0100
Patch-mainline: pending
References: FATE#306586 bnc#748632
Subject: [PATCH] btrfs: push-up errors from btrfs_num_copies

Currently handles error in btree_read_extent_buffer_pages and gracefully fails
upon mount on a corrupted image. The other paths are left unhandled for now.

Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/disk-io.c   |    3 +++
 fs/btrfs/extent_io.c |    4 ++++
 fs/btrfs/volumes.c   |   12 ++++++++++--
 3 files changed, 17 insertions(+), 2 deletions(-)

--- a/fs/btrfs/disk-io.c
+++ b/fs/btrfs/disk-io.c
@@ -390,6 +390,9 @@ static int btree_read_extent_buffer_page
 
 		num_copies = btrfs_num_copies(root->fs_info,
 					      eb->start, eb->len);
+		if (num_copies < 0)
+			return num_copies;
+
 		if (num_copies == 1)
 			break;
 
--- a/fs/btrfs/extent_io.c
+++ b/fs/btrfs/extent_io.c
@@ -2041,6 +2041,8 @@ static int clean_io_failure(u64 start, s
 		fs_info = BTRFS_I(inode)->root->fs_info;
 		num_copies = btrfs_num_copies(fs_info, failrec->logical,
 					      failrec->len);
+		BUG_ON(num_copies < 0);
+
 		if (num_copies > 1)  {
 			ret = repair_io_failure(fs_info, start, failrec->len,
 						failrec->logical, page,
@@ -2153,6 +2155,8 @@ static int bio_readpage_error(struct bio
 	}
 	num_copies = btrfs_num_copies(BTRFS_I(inode)->root->fs_info,
 				      failrec->logical, failrec->len);
+	BUG_ON(num_copies < 0);
+
 	if (num_copies == 1) {
 		/*
 		 * we only have a single copy of the data, so don't bother with
--- a/fs/btrfs/volumes.c
+++ b/fs/btrfs/volumes.c
@@ -3996,9 +3996,17 @@ int btrfs_num_copies(struct btrfs_fs_inf
 	read_lock(&em_tree->lock);
 	em = lookup_extent_mapping(em_tree, logical, len);
 	read_unlock(&em_tree->lock);
-	BUG_ON(!em);
 
-	BUG_ON(em->start > logical || em->start + em->len < logical);
+	if (!em)
+		return -EIO;
+
+	if (em->start > logical || em->start + em->len < logical) {
+		printk(KERN_CRIT "btrfs: corrupted extent, logical %llu em %llu@%llu\n",
+				(unsigned long long)logical,
+				(unsigned long long)em->start,
+				(unsigned long long)em->len);
+		return -EIO;
+	}
 	map = (struct map_lookup *)em->bdev;
 	if (map->type & (BTRFS_BLOCK_GROUP_DUP | BTRFS_BLOCK_GROUP_RAID1))
 		ret = map->num_stripes;
