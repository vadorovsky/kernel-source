From: <ohering@suse.de>
Subject: handle more than just WS2008 in KVP negotiation
References: bnc#850640
Patch-mainline: never

The sles11sp2 code stream has a hardcoded version of WS2008 for
negotiating the vmbus protocol version.  With changes made for
bnc#838346 and bnc#828714 new code was added to use this version is also
to determine the KVP protocol version.  But WS2012 and WS2012R2 do not
provide a WS2008 compatible KVP protocol.  As a result the KVP
negotiation will fail and KVP is unavailable in the guest.

Adjust the KVP negotiation to try serveral known KVP versions,
independent from the used vmbus version.

---
 drivers/hv/channel_mgmt.c |   14 ++++--------
 drivers/hv/hv_kvp.c       |   53 +++++++++++++++++++++++++++++++++-------------
 2 files changed, 44 insertions(+), 23 deletions(-)

Index: linux-3.0.101-0.5/drivers/hv/channel_mgmt.c
===================================================================
--- linux-3.0.101-0.5.orig/drivers/hv/channel_mgmt.c
+++ linux-3.0.101-0.5/drivers/hv/channel_mgmt.c
@@ -110,25 +110,21 @@ bool vmbus_prep_negotiate_resp(struct ic
 			found_match = true;
 		}
 	}
+	if (!found_match)
+		goto fw_error;
 
 	/*
 	 * Respond with the framework and service
 	 * version numbers we can support.
 	 */
 
-fw_error:
-	if (!found_match) {
-		negop->icframe_vercnt = 0;
-		negop->icmsg_vercnt = 0;
-	} else {
-		negop->icframe_vercnt = 1;
-		negop->icmsg_vercnt = 1;
-	}
-
+	negop->icframe_vercnt = 1;
+	negop->icmsg_vercnt = 1;
 	negop->icversion_data[0].major = icframe_major;
 	negop->icversion_data[0].minor = icframe_minor;
 	negop->icversion_data[1].major = icmsg_major;
 	negop->icversion_data[1].minor = icmsg_minor;
+fw_error:
 	return found_match;
 }
 
Index: linux-3.0.101-0.5/drivers/hv/hv_kvp.c
===================================================================
--- linux-3.0.101-0.5.orig/drivers/hv/hv_kvp.c
+++ linux-3.0.101-0.5/drivers/hv/hv_kvp.c
@@ -609,28 +609,53 @@ void hv_kvp_onchannelcallback(void *cont
 			sizeof(struct vmbuspipe_hdr)];
 
 		if (icmsghdrp->icmsgtype == ICMSGTYPE_NEGOTIATE) {
+			bool ret;
+			const char *ver;
 			/*
 			 * Based on the host, select appropriate
 			 * framework and service versions we will
 			 * negotiate.
 			 */
-			switch (vmbus_proto_version) {
-			case (VERSION_WS2008):
-				util_fw_version = UTIL_WS2K8_FW_VERSION;
-				kvp_srv_version = WS2008_SRV_VERSION;
-				break;
-			case (VERSION_WIN7):
-				util_fw_version = UTIL_FW_VERSION;
-				kvp_srv_version = WIN7_SRV_VERSION;
-				break;
-			default:
-				util_fw_version = UTIL_FW_VERSION;
-				kvp_srv_version = WIN8_SRV_VERSION;
-			}
-			vmbus_prep_negotiate_resp(icmsghdrp, negop,
+
+			util_fw_version = UTIL_FW_VERSION;
+			kvp_srv_version = WIN8_SRV_VERSION;
+			ver = "WIN8";
+			ret = vmbus_prep_negotiate_resp(icmsghdrp, negop,
+				 recv_buffer, util_fw_version,
+				 kvp_srv_version);
+			if (ret)
+				goto found;
+
+			util_fw_version = UTIL_FW_VERSION;
+			kvp_srv_version = WIN7_SRV_VERSION;
+			ver = "WIN7";
+			ret = vmbus_prep_negotiate_resp(icmsghdrp, negop,
 				 recv_buffer, util_fw_version,
 				 kvp_srv_version);
+			if (ret)
+				goto found;
 
+			util_fw_version = UTIL_WS2K8_FW_VERSION;
+			kvp_srv_version = WS2008_SRV_VERSION;
+			ver = "WS2008";
+			ret = vmbus_prep_negotiate_resp(icmsghdrp, negop,
+				 recv_buffer, util_fw_version,
+				 kvp_srv_version);
+			if (ret)
+				goto found;
+
+			ver = "nothing!";
+			negop = (struct icmsg_negotiate *)&recv_buffer[
+				sizeof(struct vmbuspipe_hdr) +
+				sizeof(struct icmsg_hdr)];
+			negop->icframe_vercnt = 0;
+			negop->icmsg_vercnt = 0;
+			negop->icversion_data[0].major = 0;
+			negop->icversion_data[0].minor = 0;
+			negop->icversion_data[1].major = 0;
+			negop->icversion_data[1].minor = 0;
+found:
+			pr_info("KVP negotiated for %s\n", ver);
 		} else {
 			kvp_msg = (struct hv_kvp_msg *)&recv_buffer[
 				sizeof(struct vmbuspipe_hdr) +
