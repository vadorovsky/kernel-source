From: Mel Gorman <mgorman@suse.de>
Date: Tue, 10 Jul 2012 16:31:42 +0100
Subject: [PATCH] mm: use cpu_chill() in spin_trylock_page() and cancel

References: bnc#768470
Patch-mainline: Never

Should a SCHED_FIFO task preempt the task which should modify any of
the loop conditions, we can spin forever. This is because need_resched()
never becomes true. This patch handles the problem depending differently
depending on the kernel.

For RT kernels, it will call cpu_chill() once to msleep(1) before retrying
	to lock the page. If it fails to get access it will abort, call
	sleep_on_page() which calls io_schedule() to unplug any pending IO.

For Non-RT kernels it will use cpu_relax() until it needs to reschedule
	or at least 1 lock tick has passed before going to sleep and
	unplugging IO.

Signed-off-by: Mike Galbraith <mgalbraith@suse.de>
Signed-off-by: Mel Gorman <mgorman@suse.de>
---
 mm/filemap.c |   22 ++++++++++++++++++++--
 1 file changed, 20 insertions(+), 2 deletions(-)

diff --git a/mm/filemap.c b/mm/filemap.c
index dc0df3e..d3c0b40 100644
--- a/mm/filemap.c
+++ b/mm/filemap.c
@@ -684,6 +684,21 @@ enum trylock_page_status {
 	TRYLOCK_PAGE_SCHEDULE
 };
 
+#ifndef CONFIG_PREEMPT_RT_FULL
+/* Returns true if spinning should continue */
+static bool continue_trylock_relax(unsigned long expires)
+{
+	cpu_relax();
+	return !(need_resched() || time_after(jiffies, expires));
+}
+#else
+static bool continue_trylock_relax(unsigned long expires)
+{
+	cpu_chill();
+	return false;
+}
+#endif
+
 /*
  * If a page is locked, clean and uptodate then in many cases the hold time
  * of the lock will be very short. It is better particularly on large machines
@@ -692,11 +707,14 @@ enum trylock_page_status {
  */
 static enum trylock_page_status spin_trylock_page(struct page *page)
 {
+	bool continue_spin = true;
+	unsigned long expires;
 	if (!PageUptodate(page) || PageWriteback(page) || rt_task(current))
 		return TRYLOCK_PAGE_FAILURE;
 
-	while (PageUptodate(page) && !PageWriteback(page) && !need_resched()) {
-		cpu_relax();
+	expires = jiffies + 2;
+	while (PageUptodate(page) && !PageWriteback(page) && continue_spin) {
+		continue_spin = continue_trylock_relax(expires);
 		if (!PageLocked(page) && trylock_page(page))
 			return TRYLOCK_PAGE_SUCCESS;
 	}
