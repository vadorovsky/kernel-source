From: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
Date: Fri, 1 Mar 2013 11:33:01 +0000
Patch-mainline: 3.8
Git-commit: a9870c0e031527fbfa382019f30d2e9b98124a0d
References: FATE#312888
Subject: [PATCH] Btrfs: don't call btrfs_qgroup_free if just
 btrfs_qgroup_reserve fails

commit eb6b88d92c6df083dd09a8c471011e3788dfd7c6 leads into another bug.
If it is just because qgroup_reserve fails, the function btrfs_qgroup_free
should not be called, otherwise, it will cause the wrong quota accounting.

Signed-off-by: Wang Shilong <wangsl-fnst@cn.fujitsu.com>
Signed-off-by: Josef Bacik <jbacik@fusionio.com>
Signed-off-by: David Sterba <dsterba@suse.cz>
---
 fs/btrfs/extent-tree.c |   11 ++++++-----
 1 file changed, 6 insertions(+), 5 deletions(-)

--- a/fs/btrfs/extent-tree.c
+++ b/fs/btrfs/extent-tree.c
@@ -4766,9 +4766,14 @@ int btrfs_delalloc_reserve_metadata(stru
 	 * ret != 0 here means the qgroup reservation failed, we go straight to
 	 * the shared error handling then.
 	 */
-	if (ret == 0)
+	if (ret == 0) {
 		ret = reserve_metadata_bytes(root, block_rsv,
 					     to_reserve, flush);
+		if (ret && root->fs_info->quota_enabled) {
+			btrfs_qgroup_free(root, num_bytes +
+						nr_extents * root->leafsize);
+		}
+	}
 
 	if (ret) {
 		u64 to_free = 0;
@@ -4799,10 +4804,6 @@ int btrfs_delalloc_reserve_metadata(stru
 						      btrfs_ino(inode),
 						      to_free, 0);
 		}
-		if (root->fs_info->quota_enabled) {
-			btrfs_qgroup_free(root, num_bytes +
-						nr_extents * root->leafsize);
-		}
 		if (delalloc_lock)
 			mutex_unlock(&BTRFS_I(inode)->delalloc_mutex);
 		return ret;
